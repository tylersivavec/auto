<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tysiv Auto-Battler</title>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            background-color: #222; 
            font-family: 'MedievalSharp', Arial, sans-serif;
        }
        .game-container {
            position: relative;
            width: 1600px;
            height: 800px;
            margin: 0 auto;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 1600px;
            height: 800px;
            border: 2px solid #444;
            background-color: #2a4d2a;  /* Darker green base color */
        }
        .ui-container {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 10px;
            box-sizing: border-box;
            font-family: 'MedievalSharp', Arial, sans-serif;
        }
        .shop-container {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: auto;
            padding: 10px;
            box-sizing: border-box;
        }
        .shop {
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            font-size: calc(8px + 0.5vw);
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
        }
        .shop-section {
            margin-bottom: 10px;
            padding: 5px;
            border-radius: 3px;
            background-color: rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            overflow: hidden;
            max-height: 500px;
            position: relative;
            z-index: 1;
        }
        .shop-section.collapsed {
            max-height: 30px;
            overflow: hidden;
            padding: 0;
        }
        .shop-section-title {
            text-align: center;
            margin-bottom: 5px;
            font-size: calc(10px + 0.5vw);
            color: #88ff88;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
            padding: 5px;
            position: relative;
            z-index: 1;
        }
        .shop-section-title::after {
            content: '▼';
            font-size: 0.8em;
            transition: transform 0.3s ease;
        }
        .shop-section.collapsed .shop-section-title::after {
            transform: rotate(-90deg);
        }
        .resources {
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: calc(10px + 0.7vw);
            display: flex;
            gap: 20px;
            align-items: center;
        }
        .base-health {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: calc(12px + 0.6vw);
            text-align: center;
            width: 250px;
        }
        .base-health .health-bar {
            width: 100%;
            height: 10px;
            background-color: #333;
            margin-top: 5px;
            border-radius: 4px;
            overflow: hidden;
        }
        .base-health .health-bar-fill {
            height: 100%;
            background-color: #33CC33;
            transition: width 0.3s;
        }
        .player-base-health {
            left: 10px;
            top: 10px;
        }
        .enemy-base-health {
            right: 10px;
            top: 10px;
            text-align: center;
        }
        .player-gold, .enemy-gold {
            margin-top: 8px;
            padding-top: 5px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        .gold-rate, .enemy-gold-rate {
            font-size: calc(8px + 0.4vw);
            color: #88ff88;
            margin-top: 2px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        .miners-display {
            display: flex;
            gap: 4px;
            margin-top: 3px;
            justify-content: center;
        }
        .miner-slot {
            width: 20px;
            height: 20px;
            border: 1px solid #666;
            border-radius: 3px;
            background: rgba(255, 255, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .miner-icon {
            font-size: 14px;
            animation: bounce 1s infinite;
        }
        .miner-rate {
            position: absolute;
            bottom: -12px;
            font-size: 8px;
            color: #ffcc00;
            font-weight: bold;
            text-shadow: 0 0 3px black;
        }
        .vault-slot {
            width: 20px;
            height: 20px;
            border: 1px solid #666;
            border-radius: 3px;
            background: rgba(0, 191, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .vault-icon {
            font-size: 14px;
            animation: bounce 1s infinite;
        }
        .shop-items {
            display: flex;
            flex-direction: row;
            gap: 8px;
            transition: opacity 0.3s ease;
            position: relative;
            z-index: 2;
            justify-content: center; /* Center items */
        }
        .shop-section.collapsed .shop-items {
            opacity: 0;
            pointer-events: none;
        }
        .shop-item {
            border: 1px solid #666;
            padding: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
            position: relative;
            width: 90px; /* Fixed width for all items */
            height: 80px; /* Fixed height for all items */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 3;
            background-color: rgba(0, 0, 0, 0.5); /* Consistent background */
            border-radius: 4px; /* Slightly rounded corners */
        }
        .shop-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .shop-item-emoji {
            font-size: calc(16px + 0.8vw);
            display: block;
            margin-bottom: 5px;
            height: 32px; /* Fixed height for emoji area */
        }
        .shop-item-name {
            font-weight: bold;
            margin-bottom: 3px;
        }
        .shop-item-cost {
            color: #FFCC00; /* Gold color for cost */
        }
        .shop-item.purchased {
            border: 1px solid #88ff88;
            opacity: 0.9;
            cursor: default;
        }
        .miner-count {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 0.8em;
            color: #88ff88;
        }
        .tooltip {
            visibility: hidden;
            position: fixed;
            bottom: auto;
            top: 0;
            left: 0;
            transform: translate(-50%, -100%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px;
            border-radius: 4px;
            width: max-content;
            font-size: 14px;
            margin-bottom: 5px;
            white-space: nowrap;
            z-index: 100;
            border: 1px solid #666;
            pointer-events: none;
        }
        .shop-item:hover .tooltip {
            visibility: visible;
        }
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: calc(16px + 1vw);
            z-index: 10;
        }
        #loadingBar {
            width: 80%;
            height: 20px;
            background-color: #333;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        #loadingProgress {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }
        @media (max-width: 768px) {
            .ui-container {
                flex-direction: column;
                gap: 10px;
            }
            .shop-container {
                width: 100%;
                right: 0;
            }
            .shop-items {
                flex-direction: row;
                justify-content: center;
            }
            .player-base-health {
                width: 200px;
            }
        }
        .mines-container {
            position: absolute;
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
            justify-content: center;
            width: auto;
        }
        .player-mines {
            left: calc(15% + 20px);
            top: calc(85% + 30px);
        }
        .enemy-mines {
            right: calc(15% + 20px);
            top: calc(15% + 30px);
        }
        .mine {
            font-size: 20px;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.5));
            animation: bounce 1s infinite;
            opacity: 0.9;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
        .question-mark {
            animation: float 2s ease-in-out infinite;
            opacity: 0.7;
        }
        /* Add new styles for the battle timer */
        .battle-timer {
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .battle-timer.urgent {
            color: #ff4444;
            animation: pulseTimer 0.5s ease-in-out infinite;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.7);
        }
        .battle-timer .win-bonus {
            color: #ffcc00;
            font-size: 0.9em;
            margin-top: 2px;
        }
        .battle-timer .timer-line {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        @keyframes pulseTimer {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .stats-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 2;
        }
        .base-health.player-base-health,
        .base-health.enemy-base-health {
            position: static;
            width: 250px;
            margin: 0;
            text-align: center;  /* Center the entire content */
        }
        .enemy-header {
            color: #ff4444;
            font-weight: bold;
        }
        @media (max-width: 768px) {
            .stats-panel {
                left: 0;
                width: 100%;
                align-items: center;
            }
            .base-health.player-base-health,
            .base-health.enemy-base-health {
                width: 200px;
            }
        }
        .player-header {
            color: #3399ff;
            font-weight: bold;
        }
        .player-header, .enemy-header {
            font-size: 1.2em;
            margin-bottom: 5px;
            display: block;
            text-align: center;  /* Center the headers */
        }
        .player-header {
            color: #3399ff;
            font-weight: bold;
        }
        .enemy-header {
            color: #ff4444;
            font-weight: bold;
        }
        /* Add victory popup styles */
        .victory-popup {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) scale(0.8);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            color: white;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            border: 1px solid #444;
            max-width: 300px;
            width: 80%;
        }
        .victory-popup.show {
            opacity: 1;
            transform: translateX(-50%) scale(1);
            pointer-events: auto;
        }
        .victory-popup h2 {
            font-size: 1.5em;
            margin-bottom: 8px;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        .victory-popup.player-win h2 {
            color: #33CC33;
        }
        .victory-popup.enemy-win h2 {
            color: #FF4444;
        }
        .victory-popup .gold-awarded {
            font-size: 1.2em;
            color: #FFD700;
            margin: 8px 0;
            animation: pulse 1s infinite;
        }
        .victory-popup .streak {
            font-size: 1em;
            margin: 5px 0;
            color: #FFA500;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .tutorial-highlight {
          position: absolute;
          border: 4px solid #ff0;
          border-radius: 12px;
          box-shadow: 0 0 24px 6px rgba(255,255,0,0.4);
          background: rgba(255,255,0,0.08);
          pointer-events: none;
          transition: all 0.3s;
          z-index: 5;
        }
        .tutorial-label {
          position: absolute;
          min-width: 220px;
          max-width: 340px;
          background: rgba(0,0,0,0.92);
          color: #fff;
          padding: 18px 22px;
          border-radius: 10px;
          font-size: 1.15em;
          font-family: 'MedievalSharp', Arial, sans-serif;
          box-shadow: 0 2px 16px #000;
          z-index: 6;
          pointer-events: none;
          transition: all 0.3s;
        }
        .tutorial-highlight.staging {
          border-radius: 40% 40% 60% 60%/60% 60% 40% 40%;
        }
        #tutorialStepContainer button {
          font-family: 'MedievalSharp', Arial, sans-serif;
          font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div id="startScreen" style="position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(20,20,20,0.97);z-index:20;display:flex;flex-direction:column;justify-content:center;align-items:center;">
        <div style="background:rgba(0,0,0,0.8);padding:32px 40px;border-radius:12px;box-shadow:0 0 32px #000;max-width:420px;text-align:center;">
            <h1 style="font-family:'MedievalSharp',Arial,sans-serif;font-size:2.2em;color:#fff;margin-bottom:0.5em;">tysiv Auto-Battler</h1>
            <p style="color:#ccc;font-size:1.1em;margin-bottom:1.5em;">Defend your base, build your army, and outlast the enemy in this auto-battler strategy game!</p>
            <button id="startGameBtn" style="font-size:1.2em;padding:10px 32px;margin-bottom:1em;border-radius:6px;background:#33cc33;color:#fff;border:none;cursor:pointer;">Start Game</button><br>
            <button id="howToPlayBtn" style="font-size:1em;padding:7px 18px;border-radius:6px;background:#3399ff;color:#fff;border:none;cursor:pointer;">How to Play</button>
        </div>
    </div>
    <div id="tutorialOverlay" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(10,10,30,0.97);z-index:30;justify-content:center;align-items:center;">
      <div id="tutorialStepContainer" style="position:relative;max-width:1100px;width:90vw;margin:0 auto;">
        <img src="assets/tutorial_image.JPG" id="tutorialImage" style="width:100%;border-radius:12px;box-shadow:0 0 32px #000;">
        <div id="tutorialHighlight" class="tutorial-highlight" style="display:none;"></div>
        <div id="tutorialLabel" class="tutorial-label" style="display:none;"></div>
        <button id="closeTutorialBtn" style="position:absolute;top:10px;right:10px;font-size:1.2em;background:none;border:none;color:#fff;cursor:pointer;z-index:10;">✖</button>
        <div style="position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:16px;z-index:10;">
          <button id="tutorialPrevBtn" style="font-size:1.1em;padding:6px 18px;border-radius:6px;background:#3399ff;color:#fff;border:none;cursor:pointer;">Prev</button>
          <button id="tutorialNextBtn" style="font-size:1.1em;padding:6px 18px;border-radius:6px;background:#33cc33;color:#fff;border:none;cursor:pointer;">Next</button>
        </div>
      </div>
    </div>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="loadingScreen">
            <div>Loading Game Assets...</div>
            <div id="loadingBar">
                <div id="loadingProgress"></div>
            </div>
        </div>
        <div class="ui-container">
            <div class="resources">
                <div id="nextBattleTimer" class="battle-timer"></div>
            </div>
        </div>
        <div class="stats-panel">
            <div class="base-health player-base-health">
                <span class="player-header">Player Stats</span>
                Base HP: <span id="playerBaseHealth">1000</span>
                <div class="health-bar">
                    <div class="health-bar-fill" id="playerHealthFill" style="width: 100%"></div>
                </div>
                <div class="player-gold">💰 Gold: <span id="playerGold">100</span>/<span id="maxGold">500</span></div>
                <div class="gold-rate">
                    <div>+<span id="goldRate">3</span> gold/sec</div>
                    <div class="miners-display">
                        <div class="miner-slot" style="background: rgba(255, 255, 0, 0.3);">
                            <div class="miner-icon">⛏️</div>
                            <div class="miner-rate">+1</div>
                        </div>
                        <div class="miner-slot" style="background: rgba(255, 255, 0, 0.3);">
                            <div class="miner-icon">⛏️</div>
                            <div class="miner-rate">+2</div>
                        </div>
                        <div class="miner-slot" style="background: rgba(255, 255, 0, 0.3);">
                            <div class="miner-icon">⛏️</div>
                            <div class="miner-rate">+3</div>
                        </div>
                        <div class="vault-slot" style="background: rgba(0, 191, 255, 0.3);">
                            <div class="vault-icon">💎</div>
                        </div>
                        <div class="vault-slot" style="background: rgba(0, 191, 255, 0.3);">
                            <div class="vault-icon">💎</div>
                        </div>
                        <div class="vault-slot" style="background: rgba(0, 191, 255, 0.3);">
                            <div class="vault-icon">💎</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="base-health enemy-base-health">
                <span class="enemy-header">Enemy Stats</span>
                Base HP: <span id="enemyBaseHealth">1000</span>
                <div class="health-bar">
                    <div class="health-bar-fill" id="enemyHealthFill" style="width: 100%"></div>
                </div>
                <div class="enemy-gold">💰 Gold: <span id="enemyGold">100</span>/<span id="enemyMaxGold">500</span></div>
                <div class="enemy-gold-rate">
                    <div>+<span id="enemyGoldRate">3</span> gold/sec</div>
                    <div class="miners-display">
                        <div class="miner-slot" style="background: rgba(255, 255, 0, 0.3);">
                            <div class="miner-icon">⛏️</div>
                            <div class="miner-rate">+1</div>
                        </div>
                        <div class="miner-slot" style="background: rgba(255, 255, 0, 0.3);">
                            <div class="miner-icon">⛏️</div>
                            <div class="miner-rate">+2</div>
                        </div>
                        <div class="miner-slot" style="background: rgba(255, 255, 0, 0.3);">
                            <div class="miner-icon">⛏️</div>
                            <div class="miner-rate">+3</div>
                        </div>
                        <div class="vault-slot" style="background: rgba(0, 191, 255, 0.3);">
                            <div class="vault-icon">💎</div>
                        </div>
                        <div class="vault-slot" style="background: rgba(0, 191, 255, 0.3);">
                            <div class="vault-icon">💎</div>
                        </div>
                        <div class="vault-slot" style="background: rgba(0, 191, 255, 0.3);">
                            <div class="vault-icon">💎</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="shop-container">
            <div class="shop">
                <div class="shop-section">
                    <div class="shop-section-title">Combat Units</div>
                    <div class="shop-items">
                        <div class="shop-item" onclick="buyUnit('warrior')">
                            <span class="shop-item-emoji"></span>
                            <span class="shop-item-name">Warrior</span>
                            <span class="shop-item-cost">75g</span>
                            <div class="tooltip">
                                Warrior<br>
                                Health: 450<br>
                                Unit Damage: 20 (Physical)<br>
                                Base Attack: 10<br>
                                Attack Speed: 1.5/s<br>
                                Move Speed: 1.2x<br>
                                Range: Melee<br>
                                Armor: Heavy<br>
                                Attack Type: Physical<br>
                                Damage Bonuses:<br>+50% vs Light Armor
                            </div>
                        </div>
                        <div class="shop-item" onclick="buyUnit('archer')">
                            <span class="shop-item-emoji"></span>
                            <span class="shop-item-name">Archer</span>
                            <span class="shop-item-cost">85g</span>
                            <div class="tooltip">
                                Archer<br>
                                Health: 375<br>
                                Unit Damage: 30 (Piercing)<br>
                                Base Attack: 10<br>
                                Attack Speed: 1.0/s<br>
                                Move Speed: 1.4x<br>
                                Range: Long<br>
                                Armor: Light<br>
                                Attack Type: Piercing<br>
                                Damage Bonuses:<br>+50% vs Cloth Armor
                            </div>
                        </div>
                        <div class="shop-item" onclick="buyUnit('mage')">
                            <span class="shop-item-emoji"></span>
                            <span class="shop-item-name">Mage</span>
                            <span class="shop-item-cost">100g</span>
                            <div class="tooltip">
                                Mage<br>
                                Health: 300<br>
                                Unit Damage: 50 (Magic)<br>
                                Base Attack: 10<br>
                                Attack Speed: 0.8/s<br>
                                Move Speed: 1.0x<br>
                                Range: Medium<br>
                                Armor: Cloth<br>
                                Attack Type: Magic<br>
                                Damage Bonuses:<br>+50% vs Heavy Armor
                            </div>
                        </div>
                        <div class="shop-item" onclick="buyUnit('priestess')">
                            <span class="shop-item-emoji"></span>
                            <span class="shop-item-name">Priestess</span>
                            <span class="shop-item-cost">65g</span>
                            <div class="tooltip">
                                Priestess<br>
                                Health: 250<br>
                                Unit Damage: 5 (Magic)<br>
                                Base Attack: 5<br>
                                Heal Amount: 15<br>
                                Heal Range: 100<br>
                                Heal Speed: 0.5/s<br>
                                Move Speed: 1.1x<br>
                                Range: Medium<br>
                                Armor: Cloth<br>
                                Attack Type: Magic<br>
                                Special: Heals nearby injured allies
                            </div>
                        </div>
                    </div>
                </div>
                <div class="shop-section collapsed">
                    <div class="shop-section-title">Economy</div>
                    <div class="shop-items">
                        <div class="shop-item" onclick="buyUnit('miner')">
                            <span class="shop-item-emoji">⛏️</span>
                            <span class="shop-item-name">Miner</span>
                            <span class="shop-item-cost">200g</span>
                            <div class="tooltip">
                                ⛏️ Miner<br>
                                Miner 1: 200g (+1 gold/sec)<br>
                                Miner 2: 250g (+2 gold/sec)<br>
                                Miner 3: 300g (+3 gold/sec)<br>
                                Effect: Progressive gold income<br>
                                Non-combat unit
                            </div>
                        </div>
                        <div class="shop-item" onclick="buyUnit('vault')">
                            <span class="shop-item-emoji">💎</span>
                            <span class="shop-item-name">Vault</span>
                            <span class="shop-item-cost">200g</span>
                            <div class="tooltip">
                                💎 Vault<br>
                                Vault 1: 200g<br>
                                Vault 2: 250g<br>
                                Vault 3: 300g<br>
                                Effect: Increases max gold capacity<br>
                                Non-combat unit
                            </div>
                        </div>
                    </div>
                </div>
                <div class="shop-section collapsed">
                    <div class="shop-section-title">Upgrades</div>
                    <div class="shop-items">
                        <div class="shop-item" onclick="buyUpgrade('pillage')">
                            <span class="shop-item-emoji">🏺</span>
                            <span class="shop-item-name">Pillage</span>
                            <span class="shop-item-cost">175g</span>
                            <div class="tooltip">
                                Effect: Upgrades Warrior units<br>
                                • Warriors steal 2 gold per attack on enemy base<br>
                                • Gold is transferred directly to your vault<br>
                            </div>
                        </div>
                        <div class="shop-item" onclick="buyUpgrade('poisonArrow')">
                            <span class="shop-item-emoji">🧪</span>
                            <span class="shop-item-name">Poison Arrow</span>
                            <span class="shop-item-cost">150g</span>
                            <div class="tooltip">
                                Effect: Upgrades Archer units<br>
                                • Arrows apply poison that slows target attack speed by 50%<br>
                                • Poison also slows target movement speed by 50%<br>
                                • Poison effect lasts for 5 seconds<br>
                            </div>
                        </div>
                        <div class="shop-item" onclick="buyUpgrade('arcLightning')">
                            <span class="shop-item-emoji">⚡</span>
                            <span class="shop-item-name">Arc Lightning</span>
                            <span class="shop-item-cost">200g</span>
                            <div class="tooltip">
                                Effect: Upgrades Mage units<br>
                                • Every 3 seconds, lightning chains to all nearby enemies<br>
                                • Chain damage: 50% of primary damage<br>
                                • Chain range: 150 units<br>
                            </div>
                        </div>
                        <div class="shop-item" onclick="buyUpgrade('shadowPriest')">
                            <span class="shop-item-emoji">🌑</span>
                            <span class="shop-item-name">Shadow Priestess</span>
                            <span class="shop-item-cost">150g</span>
                            <div class="tooltip">
                                Effect: Upgrades Priestess units<br>
                                • Heal: 15 → 30<br>
                                • Damage: 5 → 40<br>
                                • Base Attack: 5 → 10<br>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game constants
        const GOLD_INTERVAL = 1; // Seconds between gold increments
        const BATTLE_INTERVAL = 45; // Seconds between battles
        const BASE_GOLD_RATE = 3; // Base amount of gold earned per interval
        const MINER_GOLD_RATES = [1, 2, 3]; // Gold rate for each miner (index 0 = first miner, etc.)
        const BASE_WIN_BONUS = 75; // Base gold bonus for winning a battle
        const WIN_BONUS_INCREMENT = 25; // Additional gold per consecutive win
        const ISOMETRIC_FACTOR = 0.5; // How "flat" the isometric view appears
        const MAX_GOLD = 500; // Maximum gold cap
        const SPRITE_SIZE = 32; // Size of sprite assets
        const ANIMATION_FPS = 8; // Animation frames per second
        const SPRITE_FRAMES = {
            warrior: 1,  // Number of frames in warrior sprite
            archer: 1,   // Number of frames in archer sprite
            mage: 1      // Number of frames in mage sprite
        };
        const BASE_ATTACK_RANGE = 150; // Range at which units can attack the base
        const BASE_ATTACK_DAMAGE = 100; // Increased from 20
        const BASE_ATTACK_SPEED = 0.25; // Reduced from 0.5 (attacks every 4 seconds)
        const BASE_ATTACK_COOLDOWN = 0.25 / BASE_ATTACK_SPEED; // Time between base attacks
        const BASE_PROJECTILE_SPEED = 8; // Increased speed of base projectiles for better visibility
        
        // Load warrior sprite
        const warriorSprite = new Image();
        warriorSprite.onload = () => {
            console.log('Warrior sprite loaded successfully:', warriorSprite.src);
            console.log('Sprite dimensions:', warriorSprite.width, 'x', warriorSprite.height);
        };
        warriorSprite.onerror = (e) => {
            console.error('Error loading warrior sprite:', e);
            console.error('Attempted path:', warriorSprite.src);
        };
        warriorSprite.src = 'assets/sprites/king.png';

        // Load player base sprite
        const playerBaseSprite = new Image();
        playerBaseSprite.src = 'assets/sprites/player_base.png';

        // Load enemy base sprite
        const enemyBaseSprite = new Image();
        enemyBaseSprite.src = 'assets/sprites/enemy_base.png';

        // Load background image
        const backgroundImage = new Image();
        backgroundImage.onload = () => {
            console.log('Background image loaded successfully:', backgroundImage.src);
        };
        backgroundImage.onerror = (e) => {
            console.error('Error loading background image:', e);
            console.error('Attempted path:', backgroundImage.src);
        };
        backgroundImage.src = 'assets/background1.png';

        // Load archer sprite
        const archerSprite = new Image();
        archerSprite.onload = () => {
            console.log('Archer sprite loaded successfully:', archerSprite.src);
            console.log('Sprite dimensions:', archerSprite.width, 'x', archerSprite.height);
        };
        archerSprite.onerror = (e) => {
            console.error('Error loading archer sprite:', e);
            console.error('Attempted path:', archerSprite.src);
        };
        archerSprite.src = 'assets/sprites/leaf_ranger.png';

        // Load mage sprite
        const mageSprite = new Image();
        mageSprite.onload = () => {
            console.log('Mage sprite loaded successfully:', mageSprite.src);
            console.log('Sprite dimensions:', mageSprite.width, 'x', mageSprite.height);
        };
        mageSprite.onerror = (e) => {
            console.error('Error loading mage sprite:', e);
            console.error('Attempted path:', mageSprite.src);
        };
        mageSprite.src = 'assets/sprites/gypsy.png';

        // Load priestess sprite
        const priestessSprite = new Image();
        priestessSprite.onload = () => {
            console.log('Priestess sprite loaded successfully:', priestessSprite.src);
            console.log('Sprite dimensions:', priestessSprite.width, 'x', priestessSprite.height);
        };
        priestessSprite.onerror = (e) => {
            console.error('Error loading priestess sprite:', e);
            console.error('Attempted path:', priestessSprite.src);
        };
        priestessSprite.src = 'assets/sprites/priestess.png';

        // Grid colors and pattern
        const GRID_COLORS = {
            grass: Array(100).fill(null).map(() => {
                const baseHue = 120;  // Green
                const hueVariation = Math.random() * 20 - 10;  // ±10 variation
                const saturation = 30 + Math.random() * 20;    // 30-50%
                const lightness = 25 + Math.random() * 10;     // 25-35%
                return `hsl(${baseHue + hueVariation}, ${saturation}%, ${lightness}%)`;
            }),
            dirt: Array(20).fill(null).map(() => {
                const baseHue = 30;  // Brown
                const hueVariation = Math.random() * 20 - 10;  // ±10 variation
                const saturation = 30 + Math.random() * 20;    // 30-50%
                const lightness = 20 + Math.random() * 10;     // 20-30%
                return `hsl(${baseHue + hueVariation}, ${saturation}%, ${lightness}%)`;
            })
        };

        // Pre-calculate dirt path pattern
        const DIRT_PATTERN = new Set();
        // Create a 6x4 rectangle, horizontally oriented, shifted down 5 and right 6
        for (let i = -3 + 4; i <= 2 + 6; i++) {      // 6 columns wide, shifted right by 5
            for (let j = -2 + 5; j <= 1 + 5; j++) {  // 4 rows tall, shifted down by 5
                DIRT_PATTERN.add(`${i},${j}`);
            }
        }
        
        // Game state
        let gameState = {
            playerGold: 100,
            enemyGold: 100,
            playerBaseHealth: 1000,
            enemyBaseHealth: 1000,
            playerStagingArea: [],
            enemyStagingArea: [],
            activeUnits: [],
            playerMiners: 0,
            enemyMiners: 0,
            playerVaults: 0,
            enemyVaults: 0,
            goldTimer: GOLD_INTERVAL,
            battleTimer: BATTLE_INTERVAL,
            gameOver: false,
            draggingUnit: null,
            dragStartPos: null,
            playerBaseAttackCooldown: 0,
            enemyBaseAttackCooldown: 0,
            firstBattleOccurred: false,
            animationTimer: 0,
            currentFrame: 0,
            playerWinStreak: 0,
            enemyWinStreak: 0,
            prevPlayerWinStreak: 0,  // Add this
            prevEnemyWinStreak: 0,   // Add this
            nextBattleWinBonus: BASE_WIN_BONUS,
            battleWon: false,
            upgrades: {
                shadowPriest: false,  // Reset Shadow Priestess upgrade
                arcLightning: false,   // Reset Arc Lightning upgrade
                pillage: false,        // Reset Pillage upgrade
                poisonArrow: false     // Reset Poison Arrow upgrade
            }
        };

        // Unit definitions with emojis
        const unitTypes = {
            miner: {
                name: "Miner",
                cost: [200, 250, 300],  // Progressive costs for each miner
                emoji: "⛏️",
                isMiner: true,
                goldRates: [1, 2, 3]  // Gold rate for each miner (index 0 = first miner, etc.)
            },
            vault: {
                name: "Vault",
                cost: [200, 250, 300],  // Updated costs to match miner
                emoji: "💎",
                isVault: true,
                maxGoldIncrease: [250, 500, 750]  // Cumulative increases: +250, +500, +750
            },
            warrior: {
                name: "Warrior",
                cost: 75,
                health: 450,
                damage: 20,
                baseDamage: 10,
                attackRange: 60,
                attackSpeed: 1.5,
                moveSpeed: 1.2,
                color: "#8B0000",
                size: 32,
                damageType: "Physical",
                armorType: "Heavy",
                bonusDamage: {
                    Light: 1.5,    // 50% bonus vs Archers
                    Medium: 1.0,
                    Heavy: 1.0,
                    Cloth: 1.0
                }
            },
            archer: {
                name: "Archer",
                cost: 85,
                health: 375,
                damage: 30,
                baseDamage: 10,
                attackRange: 250,
                attackSpeed: 1.0,
                moveSpeed: 1.4,
                color: "#006400",
                size: 28,
                ranged: true,
                damageType: "Piercing",
                armorType: "Light",
                bonusDamage: {
                    Light: 1.0,
                    Medium: 1.0,
                    Heavy: 1.0,
                    Cloth: 1.5     // 50% bonus vs Mages
                }
            },
            mage: {
                name: "Mage",
                cost: 100,
                health: 300,
                damage: 50,
                baseDamage: 10,
                attackRange: 150,
                attackSpeed: 0.8,
                moveSpeed: 1.0,
                color: "#00008B",
                size: 28,
                ranged: true,
                damageType: "Magic",
                armorType: "Cloth",
                bonusDamage: {
                    Light: 1.0,
                    Medium: 1.0,
                    Heavy: 1.5,    // 50% bonus vs Warriors
                    Cloth: 1.0
                }
            },
            priestess: {
                name: "Priestess",
                cost: 65,
                health: 250,
                damage: 5,
                baseDamage: 5,
                healAmount: 15,
                healRange: 100,
                healSpeed: 0.5,    // Heals every 2 seconds
                moveSpeed: 1.1,
                color: "#FF69B4",
                size: 28,
                ranged: true,      // Make priestess ranged
                attackRange: 150,  // Add attack range
                attackSpeed: 0.8,  // Add attack speed
                damageType: "Magic",
                armorType: "Cloth",
                bonusDamage: {
                    Light: 1.0,
                    Medium: 1.0,
                    Heavy: 1.0,
                    Cloth: 1.0
                }
            }
        };

        // Get the canvas and its context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Handle responsive canvas sizing
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // Store the previous canvas dimensions
            const prevWidth = canvas.width;
            const prevHeight = canvas.height;
            
            // Set canvas dimensions based on container
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            
            // Calculate scale factors
            const scaleX = canvas.width / prevWidth;
            const scaleY = canvas.height / prevHeight;
            
            // Update game areas based on new dimensions
            updateGameAreas();
            
            // Scale active units' positions
            if (gameState.activeUnits.length > 0) {
                gameState.activeUnits.forEach(unit => {
                    if (unit) {
                        unit.x *= scaleX;
                        unit.y *= scaleY;
                    }
                });
            }
            
            // Scale projectiles' positions
            projectiles.forEach(proj => {
                if (proj) {
                    proj.x *= scaleX;
                    proj.y *= scaleY;
                    proj.targetX *= scaleX;
                    proj.targetY *= scaleY;
                }
            });
            
            // Scale base projectiles' positions
            baseProjectiles.forEach(proj => {
                if (proj) {
                    proj.x *= scaleX;
                    proj.y *= scaleY;
                    proj.targetX *= scaleX;
                    proj.targetY *= scaleY;
                }
            });
            
            // Scale particles' positions
            particles.forEach(particle => {
                if (particle) {
                    particle.x *= scaleX;
                    particle.y *= scaleY;
                }
            });
            
            // Redraw immediately if game is initialized
            if (!gameState.gameOver && gameState.gameInitialized) {
                draw();
            }
        }

        // Define game areas - will be set based on canvas size
        let gameAreas = {};
        
        function updateGameAreas() {
            const width = canvas.width;
            const height = canvas.height;
            
            // Calculate base positions along the isometric diagonal
            const baseSize = { 
                width: width * 0.08,
                height: height * 0.16
            };

            // Define the main isometric grid line (bottom-left to top-right)
            const gridStartY = height * 0.85;  // Bottom point
            const gridEndY = height * 0.15;    // Top point
            const gridStartX = width * 0.15;   // Left point
            const gridEndX = width * 0.85;     // Right point
            
            // Calculate the total diagonal distance
            const diagonalLength = Math.sqrt(
                Math.pow(gridEndX - gridStartX, 2) + 
                Math.pow(gridEndY - gridStartY, 2)
            );
            
            // Position bases closer to the edges (5% and 95%)
            const basePosition1 = 0.06;
            const basePosition2 = 0.98; // enemy base farther away
            // Position staging areas farther apart (22% and 78%)
            const stagingPosition1 = 0.18;
            const stagingPosition2 = 0.82;
            
            // Function to get point along diagonal with optional offset
            function getPointAlongDiagonal(percentage, xOffset = 0, yOffset = 0) {
                return {
                    x: gridStartX + (gridEndX - gridStartX) * percentage + xOffset,
                    y: gridStartY + (gridEndY - gridStartY) * percentage + yOffset
                };
            }
            
            // Calculate all positions with offsets for bases
            const baseOffsetX = -width * 0.03;
            const baseOffsetY = -height * 0.04; // move both bases up, but not too high
            const playerBasePos = getPointAlongDiagonal(basePosition1, baseOffsetX, baseOffsetY);
            const enemyBasePos = getPointAlongDiagonal(basePosition2, baseOffsetX, baseOffsetY);
            const playerStagingPos = getPointAlongDiagonal(stagingPosition1);
            const enemyStagingPos = getPointAlongDiagonal(stagingPosition2);
            
            // Make staging areas much larger
            const stagingSize = {
                width: width * 0.28,  // Much wider
                height: height * 0.36 // Much taller
            };
            
            gameAreas = {
                playerBase: { 
                    x: playerBasePos.x - baseSize.width/2,
                    y: playerBasePos.y - baseSize.height/2,
                    width: baseSize.width, 
                    height: baseSize.height 
                },
                enemyBase: { 
                    x: enemyBasePos.x - baseSize.width/2,
                    y: enemyBasePos.y - baseSize.height/2,
                    width: baseSize.width, 
                    height: baseSize.height 
                },
                playerStaging: { 
                    x: playerStagingPos.x - stagingSize.width/2,
                    y: playerStagingPos.y - stagingSize.height/2,
                    width: stagingSize.width, 
                    height: stagingSize.height
                },
                enemyStaging: { 
                    x: enemyStagingPos.x - stagingSize.width/2,
                    y: enemyStagingPos.y - stagingSize.height/2,
                    width: stagingSize.width, 
                    height: stagingSize.height
                }
            };
        }

        // UI elements
        const playerGoldElem = document.getElementById('playerGold');
        const enemyGoldElem = document.getElementById('enemyGold');
        const goldRateElem = document.getElementById('goldRate');
        const enemyGoldRateElem = document.getElementById('enemyGoldRate');
        const nextBattleTimerElem = document.getElementById('nextBattleTimer');
        const playerBaseHealthElem = document.getElementById('playerBaseHealth');
        const enemyBaseHealthElem = document.getElementById('enemyBaseHealth');
        const playerMinersDisplay = document.getElementById('playerMinersDisplay');
        const enemyMinersDisplay = document.getElementById('enemyMinersDisplay');
        const loadingScreen = document.getElementById('loadingScreen');
        const loadingProgress = document.getElementById('loadingProgress');

        // Projectiles array
        let projectiles = [];
        
        // Base projectiles array
        let baseProjectiles = [];
        
        // Animation timing
        let lastTime = 0;

        // Add particle system for visual effects
        let particles = [];
        
        class DamageParticle {
            constructor(x, y, damage, isPlayer, isBaseAttack = false, damageType = null) {
                this.x = x;
                this.y = y;
                this.damage = damage;
                this.isPlayer = isPlayer;
                this.isBaseAttack = isBaseAttack;
                this.damageType = damageType;
                this.life = 1.0;  // 1 second lifetime
                this.emoji = '🔥';
                this.fontSize = isBaseAttack ? 24 : 16;  // Smaller font for regular combat
                this.dy = -60;  // Move upward
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                this.dy += 120 * deltaTime;  // Gravity effect
                this.y += this.dy * deltaTime;
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save();
                
                // Only draw explosion/fire emoji for base attacks
                if (this.isBaseAttack) {
                    ctx.font = `${this.fontSize}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = Math.min(1, this.life * 2);
                    ctx.fillText(this.emoji, this.x, this.y);
                }
                
                // Set color based on damage type
                let damageColor;
                if (this.damageType === 'Physical') {
                    damageColor = '#FF4444';  // Red for physical damage
                } else if (this.damageType === 'Piercing') {
                    damageColor = '#44FF44';  // Green for piercing damage
                } else if (this.damageType === 'Magic') {
                    damageColor = '#4444FF';  // Blue for magic damage
                } else {
                    damageColor = this.isPlayer ? '#FF4444' : '#FF0000';  // Default colors
                }
                
                // Draw damage number
                ctx.font = `bold ${this.fontSize}px Arial`;
                ctx.fillStyle = damageColor;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;  // Reduced from 3 for smaller numbers
                const yOffset = this.isBaseAttack ? -20 : 0;
                ctx.strokeText(`-${this.damage}`, this.x, this.y + yOffset);
                ctx.fillText(`-${this.damage}`, this.x, this.y + yOffset);
                ctx.restore();
            }
        }

        // Initialize the game
        function initGame() {
            loadingProgress.style.width = '0%'; // <-- Move this to the top!
            console.log("Initializing game...");
            // Set up responsive canvas
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            updateMines(); // Always show miner boxes from the start
            // Make sure we have a context
            if (!ctx) {
                console.error("Could not get canvas context!");
                alert("Failed to initialize the game - canvas context not available");
                return;
            }
            // Simulate loading progress
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += 10;
                loadingProgress.style.width = `${progress}%`;
                if (progress >= 100) {
                    clearInterval(loadingInterval);
                    startGame();
                }
            }, 100);
        }

        // Start the game
        function startGame() {
            console.log("Starting game...");
            loadingScreen.style.display = 'none';
            gameState.gameInitialized = true;
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // Update coordinate conversion functions for isometric space
        function toIsoCoords(canvasX, canvasY) {
            const rect = gameAreas.playerStaging;
            const centerX = rect.x + rect.width/2;
            const centerY = rect.y + rect.height/2;
            
            // Convert to relative coordinates (-1 to 1)
            const relX = (canvasX - centerX) / (rect.width/2);
            const relY = (canvasY - centerY) / (rect.height/2);
            
            // Convert to isometric coordinates
            const isoX = (relX + relY) / 2;
            const isoY = (relY - relX) / 2;
            
            // Convert to 0-1 range
            return {
                x: Math.max(0, Math.min(1, (isoX + 1) / 2)),
                y: Math.max(0, Math.min(1, (isoY + 1) / 2))
            };
        }

        function fromIsoCoords(isoX, isoY, isPlayer) {
            const rect = isPlayer ? gameAreas.playerStaging : gameAreas.enemyStaging;
            const centerX = rect.x + rect.width/2;
            const centerY = rect.y + rect.height/2;
            
            // Convert from 0-1 to -1 to 1 range
            const normX = isoX * 2 - 1;
            const normY = isoY * 2 - 1;
            
            // Convert from isometric to screen coordinates
            const isoPoint = toIso(
                normX * (rect.width/2),
                normY * (rect.height/2)
            );
            
            return {
                x: centerX + isoPoint.x,
                y: centerY + isoPoint.y
            };
        }

        function isInStagingArea(x, y, rect) {
            // Convert to relative coordinates from center
            const centerX = rect.x + rect.width/2;
            const centerY = rect.y + rect.height/2;
            const relX = (x - centerX) / (rect.width/2);  // Divide by half-width for -1 to 1 range
            const relY = (y - centerY) / (rect.height/2); // Divide by half-height for -1 to 1 range
            
            // For isometric diamond, rotate coordinates 45 degrees
            const rotX = (relX + relY) / Math.sqrt(2);
            const rotY = (relY - relX) / Math.sqrt(2);
            
            // Check if point is inside diamond
            return Math.abs(rotX) <= 1 && Math.abs(rotY) <= 1;
        }

        // Helper function to create a unit
        function createUnit(type, isPlayer, position = null) {
            const unitTemplate = unitTypes[type];
            const unit = {
                type: type,
                isPlayer: isPlayer,
                health: unitTemplate.health,
                damage: unitTemplate.damage,
                baseDamage: unitTemplate.baseDamage,
                attackRange: unitTemplate.attackRange,
                attackSpeed: unitTemplate.attackSpeed,
                moveSpeed: unitTemplate.moveSpeed,
                ranged: unitTemplate.ranged,
                isMiner: unitTemplate.isMiner,
                damageType: unitTemplate.damageType,
                armorType: unitTemplate.armorType,
                bonusDamage: unitTemplate.bonusDamage,
                attackCooldown: 0,
                attackAnimation: 0,
                position: position || {
                    x: isPlayer ? 0.1 : 0.9,
                    y: 0.5
                }
            };

            // Add healing properties for priestess
            if (type === 'priestess') {
                unit.healAmount = unitTemplate.healAmount;
                unit.healRange = unitTemplate.healRange;
                unit.healSpeed = unitTemplate.healSpeed;
                unit.healCooldown = 0;
                
                // Apply Shadow Priest upgrade if purchased
                if (isPlayer && gameState.upgrades.shadowPriest) {
                    unit.isShadowPriest = true;
                    unit.healAmount = 30;  // Upgraded heal amount
                    unit.damage = 40;      // Upgraded damage
                    unit.baseDamage = 10;  // Upgraded base damage
                }
            }
            
            // Add Arc Lightning properties for mage
            if (type === 'mage') {
                unit.arcLightningCooldown = 0;
                
                // Apply Arc Lightning upgrade if purchased
                if (isPlayer && gameState.upgrades.arcLightning) {
                    unit.hasArcLightning = true;
                    unit.arcLightningInterval = 3; // Trigger every 3 seconds
                }
            }
            
            // Add Pillage properties for warrior
            if (type === 'warrior') {
                unit.pillageCooldown = 0;
                
                // Apply Pillage upgrade if purchased
                if (isPlayer && gameState.upgrades.pillage) {
                    unit.hasPillage = true;
                }
            }
            
            // Add Poison Arrow properties for archer
            if (type === 'archer') {
                unit.poisonArrowCooldown = 0;
                
                // Apply Poison Arrow upgrade if purchased
                if (isPlayer && gameState.upgrades.poisonArrow) {
                    unit.hasPoisonArrow = true;
                }
            }

            return unit;
        }

        // Add damage type effectiveness constants
        const DAMAGE_TYPE_EFFECTIVENESS = {
            Physical: {
                Heavy: 0.5,    // Physical attacks are weak against heavy armor
                Light: 1.5,    // Physical attacks are strong against light armor
                Cloth: 1.0     // Physical attacks are neutral against cloth
            },
            Piercing: {
                Heavy: 1.0,    // Piercing attacks are neutral against heavy armor
                Light: 1.0,    // Piercing attacks are neutral against light armor
                Cloth: 1.5     // Piercing attacks are strong against cloth
            },
            Magic: {
                Heavy: 1.5,    // Magic attacks are strong against heavy armor
                Light: 1.0,    // Magic attacks are neutral against light armor
                Cloth: 0.5     // Magic attacks are weak against cloth
            }
        };

        // Modify calculateDamage function to use damage type effectiveness
        function calculateDamage(attacker, defender) {
            if (!attacker.damageType || !defender.armorType) return attacker.damage;
            
            // Get the effectiveness multiplier based on attack type vs armor type
            const effectiveness = DAMAGE_TYPE_EFFECTIVENESS[attacker.damageType][defender.armorType] || 1.0;
            
            // Calculate final damage
            return Math.round(attacker.damage * effectiveness);
        }

        // Update projectile creation to include damage type
        function createProjectile(from, to, damage, isBaseAttack = false) {
            let projectileEmoji = "✨";
            let isPoisonArrow = false;
            
            if (from.type === "archer") {
                if (from.isPlayer && (from.hasPoisonArrow || gameState.upgrades.poisonArrow)) {
                    projectileEmoji = "🧪"; // Poison arrow projectile
                    isPoisonArrow = true;
                } else {
                    projectileEmoji = "➵"; // Regular arrow
                }
            }
            if (from.type === "mage") projectileEmoji = "⚡";
            if (from.type === "priestess") {
                if (from.isShadowPriest) {
                    projectileEmoji = "💀"; // Shadow Priestess projectile - skull symbol
                } else {
                    projectileEmoji = "💫"; // Regular Priestess projectile
                }
            }
            if (isBaseAttack) projectileEmoji = "💥"; // Base attack projectile
            
            return {
                x: from.x,
                y: from.y,
                targetX: to.x,
                targetY: to.y,
                target: to,
                speed: isBaseAttack ? BASE_PROJECTILE_SPEED : 8 * (canvas.width / 800),
                damage: damage,
                fromPlayer: from.isPlayer,
                damageType: from.damageType,
                color: isBaseAttack ? "#FF0000" : (from.isPlayer ? "#00FFFF" : "#FF00FF"),
                emoji: projectileEmoji,
                isBaseAttack: isBaseAttack,
                hasPoisonEffect: isPoisonArrow, // Only set poison effect for poison arrows
                isPoisonArrow: isPoisonArrow // Flag to identify poison arrows for styling
            };
        }

        // Modify buyUnit function to place new units in a simpler arrangement without grid snapping
        function buyUnit(unitType) {
            // Don't allow enemy to buy units during battle
            if (gameState.activeUnits.length > 0 && !gameState.playerStagingArea) {
                return;
            }
            
            let cost;
            if (unitType === 'miner') {
                const minerIndex = gameState.playerMiners;
                if (minerIndex >= 3) return;
                cost = unitTypes[unitType].cost[minerIndex];
            } else if (unitType === 'vault') {
                const vaultIndex = gameState.playerVaults;
                if (vaultIndex >= 3) return;
                cost = unitTypes[unitType].cost[vaultIndex];
            } else {
                cost = unitTypes[unitType].cost;
            }
            
            if (gameState.playerGold >= cost) {
                // Check if there's space in the staging area
                const MAX_UNITS = 12; // Maximum units allowed in staging
                if (!unitTypes[unitType].isMiner && !unitTypes[unitType].isVault && gameState.playerStagingArea.length >= MAX_UNITS) {
                    return; // Don't allow more units if at max capacity
                }

                gameState.playerGold -= cost;
                
                if (unitTypes[unitType].isMiner) {
                    gameState.playerMiners++;
                    updateMines();
                    updateMinerShopItem();
                } else if (unitTypes[unitType].isVault) {
                    gameState.playerVaults++;
                    updateMines();
                    updateVaultShopItem();
                } else {
                    // Calculate position for the new unit
                    let validPosition = false;
                    let newPosition;
                    let attempts = 0;
                    const MAX_ATTEMPTS = 20;
                    
                    while (!validPosition && attempts < MAX_ATTEMPTS) {
                        // Calculate base position in a circular pattern
                        const currentUnits = gameState.playerStagingArea.length;
                        const angle = (currentUnits * 2.4 + attempts * 0.5) % (Math.PI * 2); // Spread units around circle
                        const radius = 0.2 + (Math.random() * 0.1); // Random radius between 0.2 and 0.3
                        const centerX = 0.5;
                        const centerY = 0.5;
                        
                        newPosition = {
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        };
                        
                        // Add small random offset
                        newPosition.x += (Math.random() - 0.5) * 0.05;
                        newPosition.y += (Math.random() - 0.5) * 0.05;
                        
                        // Ensure position is within bounds
                        const padding = 0.15;
                        newPosition.x = Math.min(1 - padding, Math.max(padding, newPosition.x));
                        newPosition.y = Math.min(1 - padding, Math.max(padding, newPosition.y));
                        
                        // Check distance from other units
                        validPosition = true;
                        const MIN_DISTANCE = 0.1; // Minimum distance between units
                        
                        for (const existingUnit of gameState.playerStagingArea) {
                            const dx = existingUnit.position.x - newPosition.x;
                            const dy = existingUnit.position.y - newPosition.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < MIN_DISTANCE) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        attempts++;
                    }
                    
                    // If we couldn't find a valid position after max attempts, use the last calculated position
                    const newUnit = {
                        type: unitType,
                        position: newPosition
                    };
                    
                    // Apply Shadow Priest upgrade if applicable
                    if (unitType === 'priestess' && gameState.upgrades.shadowPriest) {
                        newUnit.isShadowPriest = true;
                    }
                    
                    // Apply Poison Arrow upgrade if applicable
                    if (unitType === 'archer' && gameState.upgrades.poisonArrow) {
                        newUnit.hasPoisonArrow = true;
                        console.log("Created new archer with Poison Arrow ability");
                    }
                    
                    gameState.playerStagingArea.push(newUnit);
                }
                
                updateUI();
            }
        }

        // Update mines visualization
        function updateMines() {
            // Update player mines and vaults
            const playerDisplay = document.querySelector('.player-base-health .miners-display');
            if (playerDisplay) {
                // Update miners
                const playerMinerSlots = playerDisplay.querySelectorAll('.miner-slot');
                playerMinerSlots.forEach((slot, index) => {
                    const icon = slot.querySelector('.miner-icon');
                    if (icon) {
                        icon.textContent = index < gameState.playerMiners ? '⛏️' : '';
                    }
                    
                    // Update miner rate display
                    const rateElem = slot.querySelector('.miner-rate');
                    if (rateElem) {
                        // Show rate if the miner is active, hide otherwise
                        if (index < gameState.playerMiners) {
                            rateElem.textContent = `+${MINER_GOLD_RATES[index]}`;
                            rateElem.style.display = 'block';
                        } else {
                            rateElem.style.display = 'none';
                        }
                    }
                });

                // Update vaults
                const playerVaultSlots = playerDisplay.querySelectorAll('.vault-slot');
                playerVaultSlots.forEach((slot, index) => {
                    const icon = slot.querySelector('.vault-icon');
                    if (icon) {
                        icon.textContent = index < gameState.playerVaults ? '💎' : '';
                    }
                });
            }

            // Update enemy mines and vaults
            const enemyDisplay = document.querySelector('.enemy-base-health .miners-display');
            if (enemyDisplay) {
                // Update miners
                const enemyMinerSlots = enemyDisplay.querySelectorAll('.miner-slot');
                enemyMinerSlots.forEach((slot, index) => {
                    const icon = slot.querySelector('.miner-icon');
                    if (icon) {
                        icon.textContent = index < gameState.enemyMiners ? '⛏️' : '';
                    }
                    
                    // Update miner rate display
                    const rateElem = slot.querySelector('.miner-rate');
                    if (rateElem) {
                        // Show rate if the miner is active, hide otherwise
                        if (index < gameState.enemyMiners) {
                            rateElem.textContent = `+${MINER_GOLD_RATES[index]}`;
                            rateElem.style.display = 'block';
                        } else {
                            rateElem.style.display = 'none';
                        }
                    }
                });

                // Update vaults
                const enemyVaultSlots = enemyDisplay.querySelectorAll('.vault-slot');
                enemyVaultSlots.forEach((slot, index) => {
                    const icon = slot.querySelector('.vault-icon');
                    if (icon) {
                        icon.textContent = index < gameState.enemyVaults ? '💎' : '';
                    }
                });
            }
        }

        // Update miner shop item state
        function updateMinerShopItem() {
            const minerShopItem = document.querySelector('.shop-item[onclick*="miner"]');
            if (gameState.playerMiners >= 3) {
                minerShopItem.classList.add('disabled');
            } else {
                minerShopItem.classList.remove('disabled');
                // Update the displayed cost to show next miner's cost
                const nextCost = unitTypes.miner.cost[gameState.playerMiners];
                const costText = minerShopItem.innerHTML.replace(/\d+g/, nextCost + 'g');
                minerShopItem.innerHTML = costText;
            }
            // Update miner count display
            let minerCount = minerShopItem.querySelector('.miner-count');
            if (!minerCount) {
                minerCount = document.createElement('div');
                minerCount.className = 'miner-count';
                minerShopItem.appendChild(minerCount);
            }
            minerCount.textContent = `${gameState.playerMiners}/3`;
        }

        // Update vault shop item state
        function updateVaultShopItem() {
            const vaultShopItem = document.querySelector('.shop-item[onclick*="vault"]');
            if (gameState.playerVaults >= 3) {
                vaultShopItem.classList.add('disabled');
            } else {
                vaultShopItem.classList.remove('disabled');
                // Update the displayed cost to show next vault's cost
                const nextCost = unitTypes.vault.cost[gameState.playerVaults];
                const costText = vaultShopItem.innerHTML.replace(/\d+g/, nextCost + 'g');
                vaultShopItem.innerHTML = costText;
            }
            // Update vault count display
            let vaultCount = vaultShopItem.querySelector('.miner-count');
            if (!vaultCount) {
                vaultCount = document.createElement('div');
                vaultCount.className = 'miner-count';
                vaultShopItem.appendChild(vaultCount);
            }
            vaultCount.textContent = `${gameState.playerVaults}/3`;
        }

        // Convert cartesian coordinates to isometric
        function toIso(x, y) {
            return {
                x: x - y,
                y: (x + y) * 0.5
            };
        }

        // Update enemy AI to use similar placement logic
        function enemyAI() {
            // Only allow enemy to purchase units when fog of war is active (between battles)
            if (gameState.activeUnits.length > 0) {
                return; // Don't buy units during battle when fog of war is not active
            }
            
            // Calculate current gold income
            const currentGoldRate = BASE_GOLD_RATE + (gameState.enemyMiners * MINER_GOLD_RATES[gameState.enemyMiners - 1]);
            
            // If we have less than 3 miners and can afford one, prioritize getting miners
            if (gameState.enemyMiners < 3) {
                const nextMinerCost = unitTypes.miner.cost[gameState.enemyMiners];
                if (gameState.enemyGold >= nextMinerCost) {
                    gameState.enemyGold -= nextMinerCost;
                    gameState.enemyMiners++;
                    updateMines();
                    return; // Exit after buying miner
                }
            }
            
            // If we have less than 3 vaults and can afford one, prioritize getting vaults
            if (gameState.enemyVaults < 3) {
                const nextVaultCost = unitTypes.vault.cost[gameState.enemyVaults];
                if (gameState.enemyGold >= nextVaultCost) {
                    gameState.enemyGold -= nextVaultCost;
                    gameState.enemyVaults++;
                    updateMines();
                    return; // Exit after buying vault
                }
            }
            
            // If we have enough gold for a unit and less than max units
            if (gameState.enemyStagingArea.length < 12) {
                // Calculate probabilities based on current situation
                const probabilities = {
                    warrior: 0.3,
                    archer: 0.3,
                    mage: 0.3
                };
                
                // Adjust probabilities based on current army composition
                const unitCounts = {
                    warrior: gameState.enemyStagingArea.filter(u => u.type === 'warrior').length,
                    archer: gameState.enemyStagingArea.filter(u => u.type === 'archer').length,
                    mage: gameState.enemyStagingArea.filter(u => u.type === 'mage').length
                };
                
                // Favor units that are underrepresented in the current army
                const totalUnits = gameState.enemyStagingArea.length || 1;
                probabilities.warrior *= (1 - unitCounts.warrior / totalUnits);
                probabilities.archer *= (1 - unitCounts.archer / totalUnits);
                probabilities.mage *= (1 - unitCounts.mage / totalUnits);
                
                // Normalize probabilities
                const totalProb = probabilities.warrior + probabilities.archer + probabilities.mage;
                probabilities.warrior /= totalProb;
                probabilities.archer /= totalProb;
                probabilities.mage /= totalProb;
                
                // Choose unit type based on probabilities
                const random = Math.random();
                let chosenType;
                if (random < probabilities.warrior) {
                    chosenType = 'warrior';
                } else if (random < probabilities.warrior + probabilities.archer) {
                    chosenType = 'archer';
                } else {
                    chosenType = 'mage';
                }
                
                // Buy the chosen unit if we can afford it
                const cost = unitTypes[chosenType].cost;
                if (gameState.enemyGold >= cost) {
                    gameState.enemyGold -= cost;
                    
                    // Use similar placement logic as player units
                    let newPosition;
                    const currentUnits = gameState.enemyStagingArea.length;
                    const angle = (currentUnits * 2.4 + Math.random()) % (Math.PI * 2);
                    const radius = 0.2 + (Math.random() * 0.1);
                    const centerX = 0.5;
                    const centerY = 0.5;
                    
                    newPosition = {
                        x: centerX + Math.cos(angle) * radius + (Math.random() - 0.5) * 0.05,
                        y: centerY + Math.sin(angle) * radius + (Math.random() - 0.5) * 0.05
                    };
                    
                    // Ensure position is within bounds
                    const padding = 0.15;
                    newPosition.x = Math.min(1 - padding, Math.max(padding, newPosition.x));
                    newPosition.y = Math.min(1 - padding, Math.max(padding, newPosition.y));
                    
                    const newUnit = {
                        type: chosenType,
                        position: newPosition
                    };
                    gameState.enemyStagingArea.push(newUnit);
                }
            }
            
            updateUI();
        }

        // Update startBattle to properly handle enemy units
        function startBattle() {
            console.log("Starting battle!");
            
            // Set first battle flag
            gameState.firstBattleOccurred = true;
            
            // Clear any existing active units
            gameState.activeUnits = [];
            
            // Move units from staging areas to active units
            gameState.playerStagingArea.forEach(unit => {
                if (unit && unit.type && unit.position) {
                    const activeUnit = createUnit(unit.type, true);
                    // Convert staging area position to actual screen position
                    const pos = fromIsoCoords(unit.position.x, unit.position.y, true);
                    activeUnit.x = pos.x;
                    activeUnit.y = pos.y;
                    
                    // Transfer Shadow Priest property if it exists
                    if (unit.type === 'priestess' && (unit.isShadowPriest || gameState.upgrades.shadowPriest)) {
                        activeUnit.isShadowPriest = true;
                        activeUnit.healAmount = 30;  // Upgraded heal amount
                        activeUnit.damage = 40;      // Upgraded damage
                        activeUnit.baseDamage = 10;  // Upgraded base damage
                    }
                    
                    // Transfer Poison Arrow property if it exists
                    if (unit.type === 'archer' && (unit.hasPoisonArrow || gameState.upgrades.poisonArrow)) {
                        activeUnit.hasPoisonArrow = true;
                    }
                    
                    // Transfer Pillage property if it exists
                    if (unit.type === 'warrior' && (unit.hasPillage || gameState.upgrades.pillage)) {
                        activeUnit.hasPillage = true;
                    }
                    
                    gameState.activeUnits.push(activeUnit);
                    console.log("Spawned player unit:", activeUnit);
                }
            });
            
            gameState.enemyStagingArea.forEach(unit => {
                if (unit && unit.type && unit.position) {
                    const activeUnit = createUnit(unit.type, false);
                    // Convert staging area position to actual screen position
                    const pos = fromIsoCoords(unit.position.x, unit.position.y, false);
                    activeUnit.x = pos.x;
                    activeUnit.y = pos.y;
                    gameState.activeUnits.push(activeUnit);
                }
            });
            
            // Clear staging areas
            gameState.playerStagingArea = [];
            gameState.enemyStagingArea = [];
            
            // Reset battle won flag
            gameState.battleWon = false;
            
            console.log("Battle started with units:", gameState.activeUnits);
        }

        // Main game loop
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000; // Convert to seconds
            lastTime = timestamp;
            
            if (!gameState.gameOver) {
                update(deltaTime);
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        // Update game state
        function update(deltaTime) {
            // Update timers
            gameState.goldTimer -= deltaTime;
            gameState.battleTimer -= deltaTime;
            
            // Give gold when timer expires
            if (gameState.goldTimer <= 0) {
                const playerMaxGold = MAX_GOLD + (gameState.playerVaults > 0 ? unitTypes.vault.maxGoldIncrease[gameState.playerVaults - 1] : 0);
                const enemyMaxGold = MAX_GOLD + (gameState.enemyVaults > 0 ? unitTypes.vault.maxGoldIncrease[gameState.enemyVaults - 1] : 0);
                
                // Calculate gold from miners using incremental rates
                let playerMinerGold = 0;
                for (let i = 0; i < gameState.playerMiners; i++) {
                    playerMinerGold += MINER_GOLD_RATES[i];
                }
                
                let enemyMinerGold = 0;
                for (let i = 0; i < gameState.enemyMiners; i++) {
                    enemyMinerGold += MINER_GOLD_RATES[i];
                }
                
                gameState.playerGold = Math.min(playerMaxGold, gameState.playerGold + BASE_GOLD_RATE + playerMinerGold);
                gameState.enemyGold = Math.min(enemyMaxGold, gameState.enemyGold + BASE_GOLD_RATE + enemyMinerGold);
                gameState.goldTimer = GOLD_INTERVAL;
                enemyAI(); // Enemy attempts to buy units
            }
            
            // Start battle when timer expires
            if (gameState.battleTimer <= 0) {
                startBattle();
                gameState.battleTimer = BATTLE_INTERVAL;
                gameState.battleWon = false;  // Reset battle won flag
                console.log("New battle starting, timer reset to:", gameState.battleTimer);
            }
            
            // Update base attack cooldowns
            if (gameState.playerBaseAttackCooldown > 0) {
                gameState.playerBaseAttackCooldown -= deltaTime;
            }
            if (gameState.enemyBaseAttackCooldown > 0) {
                gameState.enemyBaseAttackCooldown -= deltaTime;
            }

            // Update active units
            updateUnits(deltaTime);
            
            // Update projectiles
            updateProjectiles(deltaTime);
            
            // Check for battle win conditions when base is attacked
            if (gameState.activeUnits.length > 0 && !gameState.battleWon) {
                const playerUnitsAlive = gameState.activeUnits.some(unit => unit.isPlayer && unit.health > 0);
                const enemyUnitsAlive = gameState.activeUnits.some(unit => !unit.isPlayer && unit.health > 0);
                
                // Check if any unit is attacking a base
                const playerAttackingBase = gameState.activeUnits.some(unit => 
                    unit.isPlayer && 
                    unit.health > 0 && 
                    distance(unit, { x: gameAreas.enemyBase.x + gameAreas.enemyBase.width/2, y: gameAreas.enemyBase.y + gameAreas.enemyBase.height/2 }) < BASE_ATTACK_RANGE
                );
                
                const enemyAttackingBase = gameState.activeUnits.some(unit => 
                    !unit.isPlayer && 
                    unit.health > 0 && 
                    distance(unit, { x: gameAreas.playerBase.x + gameAreas.playerBase.width/2, y: gameAreas.playerBase.y + gameAreas.playerBase.height/2 }) < BASE_ATTACK_RANGE
                );
                
                // Only check for battle win if we have active units and battle hasn't been won yet
                if (!gameState.battleWon) {
                    if (enemyAttackingBase && !playerUnitsAlive) {
                        // Enemy won the battle
                        let currentWinBonus;
                        if (gameState.playerWinStreak > 0) {
                            // Breaking player's streak - use player's streak for bonus
                            currentWinBonus = BASE_WIN_BONUS + (gameState.playerWinStreak * WIN_BONUS_INCREMENT);
                        } else {
                            // Regular win - use enemy's streak
                            currentWinBonus = BASE_WIN_BONUS + (gameState.enemyWinStreak * WIN_BONUS_INCREMENT);
                        }
                        
                        // Store previous streak before updating
                        gameState.prevEnemyWinStreak = gameState.enemyWinStreak;
                        
                        // Update streaks and next battle bonus
                        if (gameState.playerWinStreak > 0) {
                            gameState.nextBattleWinBonus = BASE_WIN_BONUS; // Reset to base for next battle
                        } else {
                            gameState.nextBattleWinBonus = BASE_WIN_BONUS + ((gameState.enemyWinStreak + 1) * WIN_BONUS_INCREMENT);
                        }
                        gameState.enemyWinStreak++;
                        gameState.playerWinStreak = 0;  // Reset player streak
                        
                        // Award gold and show popup
                        const newGold = gameState.enemyGold + currentWinBonus;
                        const maxGold = MAX_GOLD + (gameState.enemyVaults > 0 ? unitTypes.vault.maxGoldIncrease[gameState.enemyVaults - 1] : 0);
                        gameState.enemyGold = Math.min(maxGold, newGold);
                        gameState.battleWon = true;
                        
                        showVictoryPopup(false, currentWinBonus, gameState.enemyWinStreak, gameState.prevEnemyWinStreak);
                        console.log("Enemy won battle by attacking base, awarded", currentWinBonus, "gold. New gold:", gameState.enemyGold, "Enemy streak:", gameState.enemyWinStreak);
                    } else if (playerAttackingBase && !enemyUnitsAlive) {
                        // Player won the battle
                        let currentWinBonus;
                        if (gameState.enemyWinStreak > 0) {
                            // Breaking enemy's streak - use enemy's streak for bonus
                            currentWinBonus = BASE_WIN_BONUS + (gameState.enemyWinStreak * WIN_BONUS_INCREMENT);
                        } else {
                            // Regular win - use player's streak
                            currentWinBonus = BASE_WIN_BONUS + (gameState.playerWinStreak * WIN_BONUS_INCREMENT);
                        }
                        
                        // Store previous streak before updating
                        gameState.prevPlayerWinStreak = gameState.playerWinStreak;
                        
                        // Update streaks and next battle bonus
                        if (gameState.enemyWinStreak > 0) {
                            gameState.nextBattleWinBonus = BASE_WIN_BONUS; // Reset to base for next battle
                        } else {
                            gameState.nextBattleWinBonus = BASE_WIN_BONUS + ((gameState.playerWinStreak + 1) * WIN_BONUS_INCREMENT);
                        }
                        gameState.playerWinStreak++;
                        gameState.enemyWinStreak = 0;  // Reset enemy streak
                        
                        // Award gold and show popup
                        const newGold = gameState.playerGold + currentWinBonus;
                        const maxGold = MAX_GOLD + (gameState.playerVaults > 0 ? unitTypes.vault.maxGoldIncrease[gameState.playerVaults - 1] : 0);
                        gameState.playerGold = Math.min(maxGold, newGold);
                        gameState.battleWon = true;
                        
                        showVictoryPopup(true, currentWinBonus, gameState.playerWinStreak, gameState.prevPlayerWinStreak);
                        console.log("Player won battle by attacking base, awarded", currentWinBonus, "gold. New gold:", gameState.playerGold, "Player streak:", gameState.playerWinStreak);
                    } else if (!playerUnitsAlive && !enemyUnitsAlive) {
                        // Draw - no bonus awarded, reset both streaks
                        gameState.prevPlayerWinStreak = gameState.playerWinStreak;  // Store previous streaks
                        gameState.prevEnemyWinStreak = gameState.enemyWinStreak;
                        gameState.playerWinStreak = 0;
                        gameState.enemyWinStreak = 0;
                        gameState.nextBattleWinBonus = BASE_WIN_BONUS;
                        gameState.battleWon = true;
                        console.log("Battle ended in draw, streaks reset");
                    }
                }
            }
            
            // Check for game over (base destroyed)
            if (gameState.playerBaseHealth <= 0 || gameState.enemyBaseHealth <= 0) {
                gameState.gameOver = true;
                setTimeout(() => {
                    alert(gameState.playerBaseHealth <= 0 ? "You lost!" : "You won!");
                    resetGame();
                }, 100);
            }
            
            updateUI();
            updateAnimations(deltaTime);
        }

        // Update active units
        function updateUnits(deltaTime) {
            for (let i = gameState.activeUnits.length - 1; i >= 0; i--) {
                const unit = gameState.activeUnits[i];
                
                // Update poison duration
                if (unit.isPoisoned) {
                    unit.poisonDuration -= deltaTime;
                    // Remove poison effect when duration ends
                    if (unit.poisonDuration <= 0) {
                        unit.isPoisoned = false;
                        unit.attackSpeed = unit.originalAttackSpeed;
                        unit.moveSpeed = unit.originalMoveSpeed;
                        delete unit.poisonColor;
                        console.log(`Poison effect ended on ${unit.type}, attack speed restored to ${unit.attackSpeed} and movement speed restored to ${unit.moveSpeed}`);
                    }
                }
                
                // Handle attack cooldown
                if (unit.attackCooldown > 0) {
                    unit.attackCooldown -= deltaTime;
                }
                
                // Handle heal cooldown for priestess
                if (unit.type === 'priestess' && unit.healCooldown > 0) {
                    unit.healCooldown -= deltaTime;
                }
                
                // Handle Arc Lightning cooldown for mage
                if (unit.type === 'mage' && unit.hasArcLightning) {
                    if (unit.arcLightningCooldown > 0) {
                        unit.arcLightningCooldown -= deltaTime;
                    }
                }
                
                // Decrease attack animation
                if (unit.attackAnimation > 0) {
                    unit.attackAnimation -= deltaTime;
                }
                
                // Find a target if none exists or current target is dead
                if (!unit.target || unit.target.health <= 0) {
                    unit.target = findTarget(unit);
                }
                
                // Handle priestess healing
                if (unit.type === 'priestess') {
                    // Find injured friendly units in range
                    const injuredAllies = gameState.activeUnits.filter(u => 
                        u.isPlayer === unit.isPlayer && 
                        u !== unit && 
                        u.health < unitTypes[u.type].health &&
                        distance(unit, u) <= unit.healRange
                    );
                    
                    // Calculate the "need to heal" factor - how badly allies need healing
                    let healingPriority = 0;
                    if (injuredAllies.length > 0) {
                        // Find the most injured ally
                        const mostInjured = injuredAllies.reduce((prev, current) => 
                            (prev.health / unitTypes[prev.type].health) < (current.health / unitTypes[current.type].health) ? prev : current
                        );
                        
                        // Calculate healing priority based on how injured the ally is
                        // 0 = full health, 1 = nearly dead
                        healingPriority = 1 - (mostInjured.health / unitTypes[mostInjured.type].health);
                    }
                    
                    // Count other priestesses nearby to avoid too many healing the same target
                    const nearbyPriestesses = gameState.activeUnits.filter(u => 
                        u.isPlayer === unit.isPlayer && 
                        u !== unit && 
                        u.type === 'priestess' &&
                        distance(unit, u) <= unit.healRange * 1.5
                    ).length;
                    
                    // Shadow priestesses are more aggressive
                    const isAggressive = unit.isShadowPriest || nearbyPriestesses > 1 || healingPriority < 0.3;
                    
                    // If there are injured allies with significant wounds AND not too many other priestesses nearby,
                    // focus on healing. Otherwise, behave more like an attacker
                    if (injuredAllies.length > 0 && healingPriority > 0.3 && nearbyPriestesses < 2) {
                        // Find the most injured ally
                        const mostInjured = injuredAllies.reduce((prev, current) => 
                            (prev.health / unitTypes[prev.type].health) < (current.health / unitTypes[current.type].health) ? prev : current
                        );
                        
                        // Move towards the injured ally if out of heal range
                        const distToAlly = distance(unit, mostInjured);
                        if (distToAlly > unit.healRange) {
                            moveTowards(unit, mostInjured.x, mostInjured.y, deltaTime);
                        } else if (unit.healCooldown <= 0) {
                            // Heal the most injured ally
                            const healAmount = Math.min(unit.healAmount, unitTypes[mostInjured.type].health - mostInjured.health);
                            mostInjured.health += healAmount;
                            
                            // Create healing particle with appropriate color for shadow priests
                            if (unit.isShadowPriest) {
                                particles.push(new HealingParticle(mostInjured.x, mostInjured.y, healAmount, true));
                            } else {
                                particles.push(new HealingParticle(mostInjured.x, mostInjured.y, healAmount, false));
                            }
                            
                            // Set heal cooldown
                            unit.healCooldown = 1 / unit.healSpeed;
                        }
                    } else {
                        // No critically injured allies or too many priestesses nearby
                        // Act like a regular attacker but with shorter attack range

                        // If we're a shadow priest, we're even more aggressive
                        if (unit.isShadowPriest) {
                            // Make shadow priests more willing to attack the base too
                            unit.baseDamage = 15; // Increased from 10 for Shadow Priestesses
                        }
                        
                        // Continue with regular attack behavior
                        if (unit.target) {
                            const distToTarget = distance(unit, unit.target);
                            
                            if (distToTarget <= unit.attackRange) {
                                if (unit.attackCooldown <= 0) {
                                    const damage = calculateDamage(unit, unit.target);
                                    
                                    if (unit.ranged) {
                                        projectiles.push(createProjectile(unit, unit.target, damage));
                                    } else {
                                        unit.target.health -= damage;
                                        particles.push(new DamageParticle(
                                            unit.target.x,
                                            unit.target.y,
                                            damage,
                                            unit.isPlayer,
                                            false,
                                            unit.damageType
                                        ));
                                    }
                                    
                                    unit.attackCooldown = 1 / unit.attackSpeed;
                                    unit.attackAnimation = 0.3;
                                    
                                    if (unit.target.health <= 0) {
                                        const targetIndex = gameState.activeUnits.indexOf(unit.target);
                                        if (targetIndex > -1) {
                                            gameState.activeUnits.splice(targetIndex, 1);
                                        }
                                        unit.target = null;
                                    }
                                }
                            } else {
                                // Move towards target
                                moveTowards(unit, unit.target.x, unit.target.y, deltaTime);
                            }
                        } else {
                            // If no target, find one or move towards enemy base
                            unit.target = findTarget(unit);
                            if (!unit.target) {
                                // Move towards enemy base
                                const targetBase = unit.isPlayer ? gameAreas.enemyBase : gameAreas.playerBase;
                                let targetBaseX = targetBase && isFinite(targetBase.x) ? targetBase.x + targetBase.width/2 : canvas.width/2;
                                let targetBaseY = targetBase && isFinite(targetBase.y) ? targetBase.y + targetBase.height/2 : canvas.height/2;
                                targetBaseX = Math.max(0, Math.min(canvas.width, targetBaseX));
                                targetBaseY = Math.max(0, Math.min(canvas.height, targetBaseY));
                                
                                moveTowards(unit, targetBaseX, targetBaseY, deltaTime);
                            }
                        }
                    }
                    
                    // Skip the regular attack logic for priestesses, unless it's a Shadow Priestess
                    // (REMOVE the next line so all priestesses can attack base)
                }
                
                // Attack target if in range
                if (unit.target) {
                    const distToTarget = distance(unit, unit.target);
                    
                    if (distToTarget <= unit.attackRange) {
                        if (unit.attackCooldown <= 0) {
                            const damage = calculateDamage(unit, unit.target);
                            
                            if (unit.ranged) {
                                projectiles.push(createProjectile(unit, unit.target, damage));
                                
                                // Check for Arc Lightning special attack
                                if (unit.type === 'mage' && unit.hasArcLightning && unit.arcLightningCooldown <= 0) {
                                    // Trigger Arc Lightning
                                    triggerArcLightning(unit, unit.target);
                                    // Reset the cooldown
                                    unit.arcLightningCooldown = unit.arcLightningInterval;
                                }
                                
                                // Check for Poison Arrow effect
                                if (unit.type === 'archer' && unit.hasPoisonArrow) {
                                    // Add poison effect to the projectile
                                    const lastIndex = projectiles.length - 1;
                                    projectiles[lastIndex].hasPoisonEffect = true;
                                }
                            } else {
                                unit.target.health -= damage;
                                
                                // Apply poison effect if needed (melee units)
                                if (unit.hasPoisonEffect) {
                                    applyPoisonEffect(unit.target);
                                }
                                
                                // Add damage particle for melee hits with damage type
                                particles.push(new DamageParticle(
                                    unit.target.x,
                                    unit.target.y,
                                    damage,
                                    unit.isPlayer,
                                    false,
                                    unit.damageType
                                ));
                            }
                            
                            unit.attackCooldown = 1 / unit.attackSpeed;
                            unit.attackAnimation = 0.3;
                            
                            if (unit.target.health <= 0) {
                                const targetIndex = gameState.activeUnits.indexOf(unit.target);
                                if (targetIndex > -1) {
                                    gameState.activeUnits.splice(targetIndex, 1);
                                }
                                unit.target = null;
                            }
                        }
                    } else {
                        // Move towards target
                        moveTowards(unit, unit.target.x, unit.target.y, deltaTime);
                    }
                } else {
                    // Move towards enemy base
                    const targetBase = unit.isPlayer ? gameAreas.enemyBase : gameAreas.playerBase;
                    let targetBaseX = targetBase && isFinite(targetBase.x) ? targetBase.x + targetBase.width/2 : canvas.width/2;
                    let targetBaseY = targetBase && isFinite(targetBase.y) ? targetBase.y + targetBase.height/2 : canvas.height/2;
                    // Clamp base target to canvas
                    targetBaseX = Math.max(0, Math.min(canvas.width, targetBaseX));
                    targetBaseY = Math.max(0, Math.min(canvas.height, targetBaseY));
                    
                    // Calculate distance to base
                    const distToBase = distance(unit, { 
                        x: targetBaseX,
                        y: targetBaseY
                    });
                    
                    if (distToBase < BASE_ATTACK_RANGE) {
                        // Unit can attack the base
                        if (unit.attackCooldown <= 0) {
                            const damage = unit.baseDamage;
                            if (unit.isPlayer) {
                                gameState.enemyBaseHealth -= damage;
                                
                                // Add random offset to damage particle position to avoid overlap
                                const offsetX = (Math.random() - 0.5) * 40;
                                const offsetY = (Math.random() - 0.5) * 30;
                                particles.push(new DamageParticle(
                                    targetBaseX + offsetX, 
                                    targetBaseY + offsetY, 
                                    damage, 
                                    true, 
                                    true
                                ));
                                
                                // Apply pillage effect for warriors
                                if (unit.type === 'warrior' && unit.hasPillage) {
                                    const goldStolen = 2; // Reduced from 5 to 2
                                    // Only steal gold if enemy has enough
                                    if (gameState.enemyGold >= goldStolen) {
                                        gameState.enemyGold -= goldStolen;
                                        gameState.playerGold += goldStolen;
                                        
                                        // Show gold stolen particle with offset to avoid overlapping with damage number
                                        particles.push(new GoldParticle(
                                            targetBaseX + 30 + offsetX, 
                                            targetBaseY - 20 + offsetY, 
                                            goldStolen,
                                            true
                                        ));
                                    }
                                }
                            } else {
                                gameState.playerBaseHealth -= damage;
                                
                                // Add random offset to damage particle position to avoid overlap
                                const offsetX = (Math.random() - 0.5) * 40;
                                const offsetY = (Math.random() - 0.5) * 30;
                                particles.push(new DamageParticle(
                                    targetBaseX + offsetX, 
                                    targetBaseY + offsetY, 
                                    damage, 
                                    false, 
                                    true
                                ));
                                
                                // Apply pillage effect for enemy warriors if they have the upgrade (future-proofing)
                                if (unit.type === 'warrior' && unit.hasPillage) {
                                    const goldStolen = 2; // Reduced from 5 to 2
                                    // Only steal gold if enemy has enough
                                    if (gameState.enemyGold >= goldStolen) {
                                        gameState.enemyGold -= goldStolen;
                                        gameState.playerGold += goldStolen;
                                        
                                        // Show gold stolen particle with offset to avoid overlapping with damage number
                                        particles.push(new GoldParticle(
                                            targetBaseX + 30 + offsetX, 
                                            targetBaseY - 20 + offsetY, 
                                            goldStolen,
                                            false
                                        ));
                                    }
                                }
                            }
                            unit.attackCooldown = 1 / unit.attackSpeed;
                            unit.attackAnimation = 0.3;
                        }
                        
                        // Base can attack back with projectile
                        if (unit.isPlayer) {
                            if (gameState.enemyBaseAttackCooldown <= 0) {
                                baseProjectiles.push(createProjectile(
                                    { x: targetBaseX, y: targetBaseY, isPlayer: false },
                                    unit,
                                    BASE_ATTACK_DAMAGE,
                                    true
                                ));
                                gameState.enemyBaseAttackCooldown = BASE_ATTACK_COOLDOWN;
                            }
                        } else {
                            if (gameState.playerBaseAttackCooldown <= 0) {
                                baseProjectiles.push(createProjectile(
                                    { x: targetBaseX, y: targetBaseY, isPlayer: true },
                                    unit,
                                    BASE_ATTACK_DAMAGE,
                                    true
                                ));
                                gameState.playerBaseAttackCooldown = BASE_ATTACK_COOLDOWN;
                            }
                        }
                    } else {
                        // Move towards base if not in range
                        if (isFinite(targetBaseX) && isFinite(targetBaseY)) {
                            moveTowards(unit, targetBaseX, targetBaseY, deltaTime);
                        }
                    }
                }
            }
            
            // Update particles
            particles = particles.filter(p => p.update(deltaTime));
        }

        // Update projectiles
        function updateProjectiles(deltaTime) {
            // Update regular projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                // Check if target still exists and is alive
                const targetExists = gameState.activeUnits.includes(proj.target) && proj.target.health > 0;
                
                if (targetExists) {
                    // Update target position if it's moving
                    proj.targetX = proj.target.x;
                    proj.targetY = proj.target.y;
                }
                
                // Move projectile towards target
                const angle = Math.atan2(proj.targetY - proj.y, proj.targetX - proj.x);
                proj.x += Math.cos(angle) * proj.speed;
                proj.y += Math.sin(angle) * proj.speed;
                
                // Add tracer particles for arc lightning
                if (proj.tracer && proj.isArcLightning) {
                    const tracerParticle = new LightningTracerParticle(proj.x, proj.y);
                    particles.push(tracerParticle);
                }
                
                // Check if projectile hit target
                const hitDistance = distance(proj, { x: proj.targetX, y: proj.targetY });
                if (hitDistance < 15) {
                    // Deal damage if target still exists
                    if (targetExists) {
                        proj.target.health -= proj.damage;
                        
                        // Apply poison effect from poison arrows
                        if (proj.hasPoisonEffect) {
                            applyPoisonEffect(proj.target);
                            
                            // Add green poison particle effect
                            particles.push(new PoisonEffectParticle(
                                proj.target.x,
                                proj.target.y
                            ));
                        }
                        
                        // Create damage particle with the projectile's damage type
                        particles.push(new DamageParticle(
                            proj.target.x,
                            proj.target.y,
                            proj.damage,
                            proj.fromPlayer,
                            false,
                            proj.damageType
                        ));
                        
                        // Special visual effect for arc lightning hit
                        if (proj.isArcLightning) {
                            particles.push(new LightningFlashParticle(proj.target.x, proj.target.y, false));
                        }
                        
                        // Remove dead targets
                        if (proj.target.health <= 0) {
                            const targetIndex = gameState.activeUnits.indexOf(proj.target);
                            if (targetIndex > -1) {
                                gameState.activeUnits.splice(targetIndex, 1);
                            }
                        }
                    }
                    
                    // Remove projectile
                    projectiles.splice(i, 1);
                }
                
                // Remove projectiles that miss (go too far)
                if (distance(proj, { x: canvas.width/2, y: canvas.height/2 }) > canvas.width) {
                    projectiles.splice(i, 1);
                }
            }

            // Update base projectiles
            for (let i = baseProjectiles.length - 1; i >= 0; i--) {
                const proj = baseProjectiles[i];
                
                // Move projectile towards target
                const angle = Math.atan2(proj.targetY - proj.y, proj.targetX - proj.x);
                proj.x += Math.cos(angle) * BASE_PROJECTILE_SPEED;
                proj.y += Math.sin(angle) * BASE_PROJECTILE_SPEED;
                
                // Check if projectile hit target
                const hitDistance = distance(proj, { x: proj.targetX, y: proj.targetY });
                if (hitDistance < 15) {
                    // Deal damage to target
                    proj.target.health -= proj.damage;
                    // Create damage particle
                    particles.push(new DamageParticle(
                        proj.target.x,
                        proj.target.y,
                        proj.damage,
                        !proj.fromPlayer, // Invert for base attacks
                        false
                    ));
                    
                    // Remove dead targets
                    if (proj.target.health <= 0) {
                        const targetIndex = gameState.activeUnits.indexOf(proj.target);
                        if (targetIndex > -1) {
                            gameState.activeUnits.splice(targetIndex, 1);
                        }
                    }
                    
                    // Remove projectile
                    baseProjectiles.splice(i, 1);
                }
                
                // Remove projectiles that miss
                if (distance(proj, { x: canvas.width/2, y: canvas.height/2 }) > canvas.width) {
                    baseProjectiles.splice(i, 1);
                }
            }
        }

        // Find nearest enemy for a unit
        function findTarget(unit) {
            let bestTarget = null;
            let bestScore = -Infinity;
            
            for (const potentialTarget of gameState.activeUnits) {
                // Skip allies
                if (potentialTarget.isPlayer === unit.isPlayer) continue;
                
                const dist = distance(unit, potentialTarget);
                
                // Calculate how many other units are targeting this one
                const targetingCount = gameState.activeUnits.filter(u => 
                    u !== unit && u.target === potentialTarget
                ).length;
                
                // Score based on distance and how many others are targeting
                // Prefer closer targets and ones that aren't being targeted as much
                const score = -dist - (targetingCount * 100);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = potentialTarget;
                }
            }
            
            return bestTarget;
        }

        // Calculate distance between two points
        function distance(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }

        // Move unit towards target
        function moveTowards(unit, targetX, targetY, deltaTime) {
            // Add slight randomization to prevent perfect stacking
            const randomness = 0.1;
            const randomX = targetX + (Math.random() * randomness - randomness/2) * 50;
            const randomY = targetY + (Math.random() * randomness - randomness/2) * 50;
            
            // Use collision avoidance for movement
            avoidCollisions(unit, randomX, randomY, deltaTime);
        }

        // Add collision avoidance function
        function avoidCollisions(unit, targetX, targetY, deltaTime) {
            const MINIMUM_SPACING = 50;  // Minimum distance between units
            let avoidanceX = 0;
            let avoidanceY = 0;
            
            // Check distance to other units
            for (const otherUnit of gameState.activeUnits) {
                if (otherUnit === unit) continue;
                
                const dx = unit.x - otherUnit.x;
                const dy = unit.y - otherUnit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < MINIMUM_SPACING) {
                    // Calculate repulsion force
                    const force = (MINIMUM_SPACING - distance) / MINIMUM_SPACING;
                    avoidanceX += (dx / distance) * force;
                    avoidanceY += (dy / distance) * force;
                }
            }
            
            // Calculate movement towards target
            const dx = targetX - unit.x;
            const dy = targetY - unit.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                const speed = (unit.moveSpeed * 100) * (canvas.width / 800) * deltaTime;
                const moveX = (dx / distance) * speed;
                const moveY = (dy / distance) * speed;
                
                // Combine target movement with collision avoidance
                const finalX = moveX + avoidanceX * speed;
                const finalY = moveY + avoidanceY * speed;
                
                // Normalize the combined movement
                const totalMovement = Math.sqrt(finalX * finalX + finalY * finalY);
                if (totalMovement > 0) {
                    unit.x += (finalX / totalMovement) * speed;
                    unit.y += (finalY / totalMovement) * speed;
                    // Clamp unit position to stay within canvas
                    unit.x = Math.max(0, Math.min(canvas.width, unit.x));
                    unit.y = Math.max(0, Math.min(canvas.height, unit.y));
                }
            }
        }

        // Draw game state
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawIsometricGrid();
            
            // Draw units
            drawUnits();
            
            // Draw projectiles
            drawProjectiles();
            
            // Draw staging areas
            drawStagingAreas();
            
            // Draw bases in front of staging areas
            drawBases();
            
            // Draw particles
            particles.forEach(p => p.draw(ctx));
            
            // Draw base projectiles
            for (const proj of baseProjectiles) {
                const rotation = Math.atan2(proj.targetY - proj.y, proj.targetX - proj.x);
                
                ctx.save();
                ctx.translate(proj.x, proj.y);
                ctx.rotate(rotation);
                
                // Draw base projectile with larger size
                ctx.font = "32px Arial";
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(proj.emoji, 0, 0);
                ctx.restore();
            }
        }

        // Draw isometric grid
        function drawIsometricGrid() {
            const gridSize = 25 * (canvas.width / 800); // Halved for smaller grid tiles
            const gridWidth = Math.ceil(canvas.width / gridSize) + 2;
            const gridHeight = Math.ceil(canvas.height / gridSize) + 4;
            
            const offsetX = canvas.width / 2;
            const offsetY = canvas.height / 2 - gridHeight * gridSize * ISOMETRIC_FACTOR / 2;

            // Draw background image first if loaded
            if (backgroundImage.complete && backgroundImage.naturalWidth > 0) {
                // Draw the background image to fill the entire canvas
                ctx.drawImage(
                    backgroundImage,
                    0, 
                    0,
                    canvas.width,
                    canvas.height
                );
            } else {
                // Fallback to colored grid if image isn't loaded
                // Function to determine if a grid cell should be dirt
                function isDirtCell(i, j) {
                    return DIRT_PATTERN.has(`${i},${j}`);
                }

                // Draw grid cells with colors
                for (let i = -gridWidth; i <= gridWidth; i++) {
                    for (let j = -gridHeight; j <= gridHeight; j++) {
                        const start = toIso(i * gridSize, j * gridSize);
                        const end = toIso((i+1) * gridSize, j * gridSize);
                        const nextRow = toIso(i * gridSize, (j+1) * gridSize);

                        // Fill cell with grass or dirt color
                        ctx.beginPath();
                        ctx.moveTo(offsetX + start.x, offsetY + start.y);
                        ctx.lineTo(offsetX + end.x, offsetY + end.y);
                        ctx.lineTo(offsetX + end.x + (nextRow.x - start.x), offsetY + end.y + (nextRow.y - start.y));
                        ctx.lineTo(offsetX + nextRow.x, offsetY + nextRow.y);
                        ctx.closePath();

                        // Get consistent color based on position
                        const colorIndex = Math.abs((i * 7 + j * 13) % (isDirtCell(i, j) ? GRID_COLORS.dirt.length : GRID_COLORS.grass.length));
                        ctx.fillStyle = isDirtCell(i, j) ? 
                            GRID_COLORS.dirt[colorIndex] : 
                            GRID_COLORS.grass[colorIndex];
                        ctx.fill();
                    }
                }
            }
            
            // Draw grid lines with slight transparency
            for (let i = -gridWidth; i <= gridWidth; i++) {
                for (let j = -gridHeight; j <= gridHeight; j++) {
                    const start = toIso(i * gridSize, j * gridSize);
                    const end = toIso((i+1) * gridSize, j * gridSize);
                    const nextRow = toIso(i * gridSize, (j+1) * gridSize);

                    // Draw only the grid lines
                    ctx.beginPath();
                    ctx.moveTo(offsetX + start.x, offsetY + start.y);
                    ctx.lineTo(offsetX + end.x, offsetY + end.y);
                    ctx.lineTo(offsetX + end.x + (nextRow.x - start.x), offsetY + end.y + (nextRow.y - start.y));
                    ctx.lineTo(offsetX + nextRow.x, offsetY + nextRow.y);
                    ctx.closePath();
                    
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.15)"; // Slightly more visible grid lines
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }

        // Draw bases
        function drawBases() {
            const playerBaseRect = gameAreas.playerBase;
            const enemyBaseRect = gameAreas.enemyBase;

            // Scale factor
            const scale = 1.5;

            // Player base
            ctx.save();
            if (playerBaseSprite.complete && playerBaseSprite.naturalWidth > 0) {
                const newWidth = playerBaseRect.width * scale;
                const newHeight = playerBaseRect.height * scale;
                ctx.drawImage(
                    playerBaseSprite,
                    playerBaseRect.x + (playerBaseRect.width - newWidth) / 2,
                    playerBaseRect.y + (playerBaseRect.height - newHeight) / 2,
                    newWidth,
                    newHeight
                );
            }
            ctx.restore();

            // Enemy base
            ctx.save();
            if (enemyBaseSprite.complete && enemyBaseSprite.naturalWidth > 0) {
                const newWidth = enemyBaseRect.width * scale;
                const newHeight = enemyBaseRect.height * scale;
                ctx.drawImage(
                    enemyBaseSprite,
                    enemyBaseRect.x + (enemyBaseRect.width - newWidth) / 2,
                    enemyBaseRect.y + (enemyBaseRect.height - newHeight) / 2,
                    newWidth,
                    newHeight
                );
            }
            ctx.restore();
        }

        // Draw staging areas
        function drawStagingAreas() {
            const playerStagingRect = gameAreas.playerStaging;
            const enemyStagingRect = gameAreas.enemyStaging;

            function drawIsometricStagingArea(rect, isPlayer, units) {
                const centerX = rect.x + rect.width / 2;
                const centerY = rect.y + rect.height / 2;
                
                // Draw staging area border in isometric view
                const points = [
                    { x: -rect.width/2, y: -rect.height/2 },
                    { x: rect.width/2, y: -rect.height/2 },
                    { x: rect.width/2, y: rect.height/2 },
                    { x: -rect.width/2, y: rect.height/2 }
                ].map(p => {
                    const iso = toIso(p.x, p.y);
                    return {
                        x: centerX + iso.x,
                        y: centerY + iso.y
                    };
                });

                // Draw staging area border
                ctx.strokeStyle = isPlayer ? "#0099FF" : "#FF0000";
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);

                // Check if we should show fog of war
                const showFog = !isPlayer && gameState.battleTimer > 1 && gameState.activeUnits.length === 0;

                if (showFog) {
                    // Draw fog of war effect
                    ctx.save();
                    
                    // Fill the entire staging area with completely opaque dark color
                    ctx.fillStyle = '#000000';  // Solid black
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    // Add subtle pattern to the fog
                    ctx.fillStyle = 'rgba(50, 50, 50, 0.2)';
                    const patternSize = 20;
                    const patternOffset = Date.now() / 5000; // Slow movement

                    // Calculate center of the staging area
                    const centerX = rect.x + rect.width / 2;
                    const centerY = rect.y + rect.height / 2;

                    // Adjust pattern to match isometric perspective
                    for (let x = -rect.width/2; x < rect.width/2; x += patternSize) {
                        for (let y = -rect.height/2; y < rect.height/2; y += patternSize) {
                            // Convert to isometric coordinates
                            const isoPoint = toIso(x, y);
                            const screenX = centerX + isoPoint.x;
                            const screenY = centerY + isoPoint.y;
                            
                            // Convert point to relative isometric coordinates
                            const relX = x / (rect.width/2);
                            const relY = y / (rect.height/2);
                            
                            // For isometric diamond, rotate coordinates 45 degrees
                            const rotX = (relX + relY) / Math.sqrt(2);
                            const rotY = (relY - relX) / Math.sqrt(2);
                            
                            // Only draw if inside isometric diamond
                            if (Math.abs(rotX) <= 0.8 && Math.abs(rotY) <= 0.8) {
                                const noiseValue = Math.sin(x * 0.1 + y * 0.1 + patternOffset) * 0.5 + 0.5;
                                if (noiseValue > 0.5) {
                                    ctx.fillRect(screenX - patternSize/4, screenY - patternSize/4, patternSize/2, patternSize/2);
                                }
                            }
                        }
                    }

                    // Draw a border around the fog
                    ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Draw question marks for each enemy unit
                    if (units && units.length > 0) {
                        ctx.font = 'bold 32px Arial';
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.lineWidth = 3;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        const currentTime = Date.now();
                        const gridSize = Math.min(rect.width, rect.height) / 4;
                        
                        units.forEach((_, index) => {
                            const row = Math.floor(index / 3);
                            const col = index % 3;
                            
                            const baseX = (col - 1) * gridSize;
                            const baseY = (row - 0.5) * gridSize;
                            
                            const isoPoint = toIso(baseX, baseY);
                            const x = centerX + isoPoint.x;
                            const y = centerY + isoPoint.y;
                            
                            const floatOffset = Math.sin((currentTime + index * 500) / 1000) * 5;
                            
                            // Draw question mark with outline for better visibility
                            ctx.strokeText('?', x, y + floatOffset);
                            ctx.fillText('?', x, y + floatOffset);
                        });
                    }

                    ctx.restore();
                } else {
                    // Draw actual units
                    if (units && Array.isArray(units)) {
                        units.forEach(unit => {
                            if (!unit || !unit.position || !unit.type) return;

                            const pos = fromIsoCoords(unit.position.x, unit.position.y, isPlayer);
                            
                            ctx.save();
                            // Apply Shadow Priestess tint if needed - double check here
                            if (isPlayer && unit.type === 'priestess' && (unit.isShadowPriest === true || gameState.upgrades.shadowPriest === true)) {
                                // Apply dark blue tint for Shadow Priestesses
                                ctx.filter = 'hue-rotate(210deg) saturate(1.2) brightness(0.8)';
                                console.log("Applied Shadow Priestess tint in staging area");
                            } else if (isPlayer && unit.type === 'archer' && (unit.hasPoisonArrow === true || gameState.upgrades.poisonArrow === true)) {
                                // Apply green tint for Poison Arrow archers
                                ctx.filter = 'hue-rotate(70deg) saturate(1.5) brightness(0.9)';
                                console.log("Applied Poison Arrow tint in staging area");
                                
                                // Draw poison particles around the archer
                                ctx.globalAlpha = 0.6;
                                ctx.fillStyle = '#22AA22';
                                for (let i = 0; i < 5; i++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = 5 + Math.random() * 10;
                                    const particleX = pos.x + Math.cos(angle) * distance;
                                    const particleY = pos.y + Math.sin(angle) * distance;
                                    ctx.beginPath();
                                    ctx.arc(particleX, particleY, 2 + Math.random() * 2, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                                ctx.globalAlpha = 1.0;
                                
                                // Remove the poison flask emoji line
                            } else if (!isPlayer) {
                                ctx.filter = 'brightness(1.1) sepia(0.2) saturate(1.2) hue-rotate(-30deg)';
                            }
                            
                            if (gameState.draggingUnit === unit) {
                                ctx.globalAlpha = 0.7;
                            }

                            // Draw unit based on type
                            if (unit.type === 'warrior' && warriorSprite.complete) {
                                ctx.drawImage(
                                    warriorSprite,
                                    0, 0,
                                    SPRITE_SIZE, SPRITE_SIZE,
                                    pos.x - SPRITE_SIZE/2,
                                    pos.y - SPRITE_SIZE/2,
                                    SPRITE_SIZE, SPRITE_SIZE
                                );
                            } else if (unit.type === 'archer' && archerSprite.complete) {
                                ctx.drawImage(
                                    archerSprite,
                                    0, 0,
                                    SPRITE_SIZE, SPRITE_SIZE,
                                    pos.x - SPRITE_SIZE/2,
                                    pos.y - SPRITE_SIZE/2,
                                    SPRITE_SIZE, SPRITE_SIZE
                                );
                            } else if (unit.type === 'mage' && mageSprite.complete) {
                                ctx.drawImage(
                                    mageSprite,
                                    0, 0,
                                    SPRITE_SIZE, SPRITE_SIZE,
                                    pos.x - SPRITE_SIZE/2,
                                    pos.y - SPRITE_SIZE/2,
                                    SPRITE_SIZE, SPRITE_SIZE
                                );
                            } else if (unit.type === 'priestess' && priestessSprite.complete) {
                                ctx.drawImage(
                                    priestessSprite,
                                    0, 0,
                                    SPRITE_SIZE, SPRITE_SIZE,
                                    pos.x - SPRITE_SIZE/2,
                                    pos.y - SPRITE_SIZE/2,
                                    SPRITE_SIZE, SPRITE_SIZE
                                );
                            } else {
                                ctx.font = '32px Arial';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(unitTypes[unit.type].emoji || '', pos.x, pos.y);
                            }
                            
                            if (gameState.draggingUnit === unit) {
                                ctx.strokeStyle = '#FFFF00';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([5, 5]);
                                ctx.beginPath();
                                ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
                                ctx.stroke();
                                ctx.setLineDash([]);
                            }
                            
                            ctx.restore();
                        });
                    }
                }
            }

            // Draw player staging area first (bottom layer)
            drawIsometricStagingArea(playerStagingRect, true, gameState.playerStagingArea);
            // Draw enemy staging area last (top layer)
            drawIsometricStagingArea(enemyStagingRect, false, gameState.enemyStagingArea);
        }

        // Draw units with attack animation
        function drawUnits() {
            // Draw active units
            gameState.activeUnits.forEach(unit => {
                if (!unit || !unit.type) return;
                
                ctx.save();
                
                // Draw red aura/outline for enemy units
                if (!unit.isPlayer) {
                    // Remove the old tint filter and use a red aura instead
                    // ctx.filter = 'brightness(1.1) sepia(0.2) saturate(1.2) hue-rotate(-30deg)';
                    
                    // Draw a red glow around enemy units
                    ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
                    ctx.shadowBlur = 10;
                    
                    // Remove the red outline circle
                    // ctx.beginPath();
                    // ctx.arc(unit.x, unit.y, SPRITE_SIZE/2 + 3, 0, Math.PI * 2);
                    // ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                    // ctx.lineWidth = 2;
                    // ctx.stroke();
                } else {
                    // Add a blue glow around player units
                    ctx.shadowColor = 'rgba(0, 100, 255, 0.8)';
                    ctx.shadowBlur = 10;
                    
                    // Apply upgrade-specific tints after setting the glow
                    if (unit.type === 'priestess' && (unit.isShadowPriest || gameState.upgrades.shadowPriest)) {
                        // Apply dark blue tint for Shadow Priestesses
                        ctx.filter = 'hue-rotate(210deg) saturate(1.2) brightness(0.8)';
                    } else if (unit.type === 'archer' && (unit.hasPoisonArrow || gameState.upgrades.poisonArrow)) {
                        // Apply green tint for Poison Arrow archers
                        ctx.filter = 'hue-rotate(70deg) saturate(1.5) brightness(0.9)';
                    }
                }
                
                // Apply poison effect visual (green tint)
                if (unit.isPoisoned) {
                    // Apply a green tint for poisoned units
                    ctx.filter = 'hue-rotate(90deg) saturate(1.5) brightness(0.9)';
                }
                
                // Calculate scale based on attack animation
                let scale = 1.0;
                if (unit.attackAnimation > 0) {
                    const animationProgress = unit.attackAnimation / 0.3;
                    if (animationProgress > 0.5) {
                        scale = 1 + (0.3 * (1 - animationProgress));
                    } else {
                        scale = 1 + (0.3 * animationProgress * 2);
                    }
                }
                
                // Apply scale transformation
                ctx.translate(unit.x, unit.y);
                ctx.scale(scale, scale);
                ctx.translate(-unit.x, -unit.y);
                
                // Draw appropriate sprite based on unit type
                let spriteDrawn = false;
                if (unit.type === 'warrior' && warriorSprite.complete) {
                    ctx.drawImage(
                        warriorSprite,
                        0, 0,
                        SPRITE_SIZE, SPRITE_SIZE,
                        unit.x - SPRITE_SIZE/2,
                        unit.y - SPRITE_SIZE/2,
                        SPRITE_SIZE, SPRITE_SIZE
                    );
                    spriteDrawn = true;
                } else if (unit.type === 'archer' && archerSprite.complete) {
                    ctx.drawImage(
                        archerSprite,
                        0, 0,
                        SPRITE_SIZE, SPRITE_SIZE,
                        unit.x - SPRITE_SIZE/2,
                        unit.y - SPRITE_SIZE/2,
                        SPRITE_SIZE, SPRITE_SIZE
                    );
                    spriteDrawn = true;
                    
                    // Draw poison effect for archers with the upgrade
                    if (unit.isPlayer && (unit.hasPoisonArrow || gameState.upgrades.poisonArrow)) {
                        // Draw small poison particles around the archer
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = '#22AA22';
                        for (let i = 0; i < 5; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 10 + Math.random() * 10;
                            const particleX = Math.cos(angle) * distance;
                            const particleY = Math.sin(angle) * distance;
                            ctx.beginPath();
                            ctx.arc(particleX, particleY, 2 + Math.random() * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1.0;
                        
                        // Draw poison flask emoji
                        ctx.font = '14px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('🧪', 15, -15);
                    }
                } else if (unit.type === 'mage' && mageSprite.complete) {
                    ctx.drawImage(
                        mageSprite,
                        0, 0,
                        SPRITE_SIZE, SPRITE_SIZE,
                        unit.x - SPRITE_SIZE/2,
                        unit.y - SPRITE_SIZE/2,
                        SPRITE_SIZE, SPRITE_SIZE
                    );
                    spriteDrawn = true;
                } else if (unit.type === 'priestess' && priestessSprite.complete) {
                    ctx.drawImage(
                        priestessSprite,
                        0, 0,
                        SPRITE_SIZE, SPRITE_SIZE,
                        unit.x - SPRITE_SIZE/2,
                        unit.y - SPRITE_SIZE/2,
                        SPRITE_SIZE, SPRITE_SIZE
                    );
                    spriteDrawn = true;
                } else {
                    ctx.font = '32px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(unitTypes[unit.type].emoji || '', unit.x, unit.y);
                }
                
                // If sprite wasn't drawn, show a colored circle as fallback
                if (!spriteDrawn && unit.type !== 'miner') {
                    ctx.beginPath();
                    ctx.arc(unit.x, unit.y, SPRITE_SIZE/2, 0, Math.PI * 2);
                    ctx.fillStyle = unitTypes[unit.type].color;
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw unit type text or emoji
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(unitTypes[unit.type].emoji || '', unit.x, unit.y);
                } else if (unit.type === 'miner') {
                    // Draw miner emoji
                    ctx.font = '32px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('⛏️', unit.x, unit.y);
                }
                
                ctx.restore();
                
                // Draw health bar
                const healthPercent = unit.health / unitTypes[unit.type].health;
                ctx.fillStyle = healthPercent > 0.5 ? '#33CC33' : '#FF3333';
                ctx.fillRect(unit.x - 15, unit.y - 25, 30 * healthPercent, 5);
                ctx.strokeStyle = '#000000';
                ctx.strokeRect(unit.x - 15, unit.y - 25, 30, 5);
                
                // Remove the team indicator above health bar
                // if (!unit.isPlayer) {
                //     ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                //     ctx.fillRect(unit.x - 15, unit.y - 32, 30, 3);
                // }
            });

            // Draw staging area units
            function drawStagingUnits(units, isPlayer) {
                units.forEach(unit => {
                    if (!unit || !unit.type) return;
                    
                    const pos = fromIsoCoords(unit.position.x, unit.position.y, isPlayer);
                    
                    // Debug log for archer units
                    if (isPlayer && unit.type === 'archer') {
                        console.log("Drawing archer in staging area:", {
                            hasPoisonArrow: unit.hasPoisonArrow,
                            upgradeActive: gameState.upgrades.poisonArrow
                        });
                    }
                    
                    ctx.save();
                    
                    // Apply team color filter or upgrade filters
                    if (isPlayer && unit.type === 'priestess' && (unit.isShadowPriest === true || gameState.upgrades.shadowPriest === true)) {
                        // Apply dark blue tint for Shadow Priestesses
                        ctx.filter = 'hue-rotate(210deg) saturate(1.2) brightness(0.8)';
                        console.log("Applied Shadow Priestess tint in drawStagingUnits");
                    } else if (isPlayer && unit.type === 'archer' && (unit.hasPoisonArrow === true || gameState.upgrades.poisonArrow === true)) {
                        // Apply green tint for Poison Arrow archers
                        ctx.filter = 'hue-rotate(70deg) saturate(1.5) brightness(0.9)';
                        console.log("Applied Poison Arrow tint in drawStagingUnits");
                        
                        // Draw poison particles around archer
                        ctx.globalAlpha = 0.6;
                        ctx.fillStyle = '#22AA22';
                        for (let i = 0; i < 5; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 5 + Math.random() * 10;
                            const particleX = pos.x + Math.cos(angle) * distance;
                            const particleY = pos.y + Math.sin(angle) * distance;
                            ctx.beginPath();
                            ctx.arc(particleX, particleY, 2 + Math.random() * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1.0;
                        
                        // Remove poison flask emoji drawing code
                    } else if (!isPlayer) {
                        ctx.filter = 'brightness(1.2) sepia(1) saturate(8) hue-rotate(-30deg)';
                    } else {
                        ctx.filter = 'none';
                    }
                    
                    // Apply poison effect visual if unit is poisoned
                    if (unit.isPoisoned) {
                        ctx.filter = 'hue-rotate(90deg) saturate(1.5) brightness(0.9)';
                    }
                    
                    // Draw unit based on type
                    let spriteDrawn = false;
                    if (unit.type === 'warrior' && warriorSprite.complete) {
                        ctx.drawImage(
                            warriorSprite,
                            0, 0,
                            SPRITE_SIZE, SPRITE_SIZE,
                            pos.x - SPRITE_SIZE/2,
                            pos.y - SPRITE_SIZE/2,
                            SPRITE_SIZE, SPRITE_SIZE
                        );
                        spriteDrawn = true;
                    } else if (unit.type === 'archer' && archerSprite.complete) {
                        ctx.drawImage(
                            archerSprite,
                            0, 0,
                            SPRITE_SIZE, SPRITE_SIZE,
                            pos.x - SPRITE_SIZE/2,
                            pos.y - SPRITE_SIZE/2,
                            SPRITE_SIZE, SPRITE_SIZE
                        );
                        spriteDrawn = true;
                    } else if (unit.type === 'mage' && mageSprite.complete) {
                        ctx.drawImage(
                            mageSprite,
                            0, 0,
                            SPRITE_SIZE, SPRITE_SIZE,
                            pos.x - SPRITE_SIZE/2,
                            pos.y - SPRITE_SIZE/2,
                            SPRITE_SIZE, SPRITE_SIZE
                        );
                        spriteDrawn = true;
                    } else if (unit.type === 'priestess' && priestessSprite.complete) {
                        ctx.drawImage(
                            priestessSprite,
                            0, 0,
                            SPRITE_SIZE, SPRITE_SIZE,
                            pos.x - SPRITE_SIZE/2,
                            pos.y - SPRITE_SIZE/2,
                            SPRITE_SIZE, SPRITE_SIZE
                        );
                        spriteDrawn = true;
                    } else {
                        ctx.font = '32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(unitTypes[unit.type].emoji || '', pos.x, pos.y);
                    }
                    
                    // If sprite wasn't drawn, show a colored circle as fallback
                    if (!spriteDrawn && unit.type !== 'miner') {
                        ctx.beginPath();
                        ctx.arc(pos.x, pos.y, SPRITE_SIZE/2, 0, Math.PI * 2);
                        ctx.fillStyle = unitTypes[unit.type].color;
                        ctx.fill();
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Draw unit type text or emoji
                        ctx.fillStyle = '#fff';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(unitTypes[unit.type].emoji || '', pos.x, pos.y);
                    } else if (unit.type === 'miner') {
                        // Draw miner emoji
                        ctx.font = '32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('⛏️', pos.x, pos.y);
                    }
                    
                    ctx.restore();
                    
                    // Draw health bar for staging units
                    const healthPercent = 1; // Staging units are always at full health
                    ctx.fillStyle = '#33CC33';
                    ctx.fillRect(pos.x - 15, pos.y - 25, 30 * healthPercent, 5);
                    ctx.strokeStyle = '#000000';
                    ctx.strokeRect(pos.x - 15, pos.y - 25, 30, 5);
                });
            }
            
            // Call the drawStagingUnits function to display staging area units
            drawStagingUnits(gameState.playerStagingArea, true);
            drawStagingUnits(gameState.enemyStagingArea, false);
        }

        // Draw projectiles
        function drawProjectiles() {
            for (const proj of projectiles) {
                const rotation = Math.atan2(proj.targetY - proj.y, proj.targetX - proj.x);
                
                ctx.save();
                ctx.translate(proj.x, proj.y);
                ctx.rotate(rotation);
                
                // Special drawing for arc lightning projectiles
                if (proj.isArcLightning) {
                    // Draw a zigzag lightning bolt instead of just the emoji
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    
                    // Create a zigzag pattern
                    const zigzagLength = 20;
                    const zigzagHeight = 5;
                    let xPos = 0;
                    
                    for (let i = 0; i < 3; i++) {
                        xPos += zigzagLength / 2;
                        ctx.lineTo(xPos, (i % 2 === 0) ? zigzagHeight : -zigzagHeight);
                    }
                    
                    ctx.strokeStyle = '#66CCFF'; // Light blue color
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Add a glow effect
                    ctx.shadowColor = '#66CCFF';
                    ctx.shadowBlur = 10;
                    ctx.stroke();
                    
                    // Also draw the emoji
                    ctx.font = "20px Arial";
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(proj.emoji, 0, 0);
                } else if (proj.isPoisonArrow) {
                    // Special styling for poison arrows
                    ctx.font = "20px Arial";
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Add a green glow effect for poison arrows
                    ctx.shadowColor = '#33CC33';
                    ctx.shadowBlur = 8;
                    ctx.fillStyle = '#33CC33'; // Green color for poison
                    ctx.fillText(proj.emoji, 0, 0);
                    
                    // Draw small poison particles
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = '#22AA22';
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 5 + Math.random() * 8;
                        const particleX = Math.cos(angle) * distance;
                        const particleY = Math.sin(angle) * distance;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, 2 + Math.random() * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0;
                } else if (proj.emoji === "➵") {
                    // Special styling for regular arrows - using the original arrow emoji
                    ctx.font = "22px Arial";
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Add a slight shadow for depth
                    ctx.shadowColor = '#000000';
                    ctx.shadowBlur = 3;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    
                    // Add black outline for better visibility
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#000000';
                    ctx.strokeText(proj.emoji, 0, 0);
                    
                    // Use a solid brown color for regular arrows
                    ctx.fillStyle = '#8B4513'; // Solid brown color
                    ctx.fillText(proj.emoji, 0, 0);
                } else {
                    // Regular projectile drawing
                    ctx.font = "20px Arial";
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(proj.emoji, 0, 0);
                }
                
                ctx.restore();
            }
        }

        // Draw health bar
        function drawHealthBar(x, y, width, height, fillPercent) {
            ctx.fillStyle = "#333333";
            ctx.fillRect(x, y, width, height);
            
            const healthColor = fillPercent > 0.6 ? "#33CC33" : fillPercent > 0.3 ? "#FFCC00" : "#CC3333";
            ctx.fillStyle = healthColor;
            ctx.fillRect(x, y, width * fillPercent, height);
            
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, width, height);
        }

        // Update UI elements
        function updateUI() {
            playerGoldElem.textContent = gameState.playerGold;
            enemyGoldElem.textContent = gameState.enemyGold;
            document.getElementById('maxGold').textContent = MAX_GOLD + (gameState.playerVaults > 0 ? unitTypes.vault.maxGoldIncrease[gameState.playerVaults - 1] : 0);
            document.getElementById('enemyMaxGold').textContent = MAX_GOLD + (gameState.enemyVaults > 0 ? unitTypes.vault.maxGoldIncrease[gameState.enemyVaults - 1] : 0);
            
            // Calculate total gold rates from miners
            let playerMinerGold = 0;
            for (let i = 0; i < gameState.playerMiners; i++) {
                playerMinerGold += MINER_GOLD_RATES[i];
            }
            
            let enemyMinerGold = 0;
            for (let i = 0; i < gameState.enemyMiners; i++) {
                enemyMinerGold += MINER_GOLD_RATES[i];
            }
            
            goldRateElem.textContent = BASE_GOLD_RATE + playerMinerGold;
            enemyGoldRateElem.textContent = BASE_GOLD_RATE + enemyMinerGold;
            
            // Update battle timer with urgent styling and win bonus
            const battleTime = Math.ceil(gameState.battleTimer);
            const prefixText = gameState.firstBattleOccurred ? "Next Battle" : "First Battle";
            
            nextBattleTimerElem.innerHTML = `
                <div class="timer-line">
                    ${prefixText}: ${battleTime}s
                </div>
                <span class="win-bonus">${gameState.nextBattleWinBonus}g win bonus</span>
            `;
            
            // Add urgent class for last 5 seconds
            if (battleTime <= 5) {
                nextBattleTimerElem.classList.add('urgent');
            } else {
                nextBattleTimerElem.classList.remove('urgent');
            }
            
            playerBaseHealthElem.textContent = Math.max(0, Math.round(gameState.playerBaseHealth));
            enemyBaseHealthElem.textContent = Math.max(0, Math.round(gameState.enemyBaseHealth));
            
            // Update health bar fills
            const playerHealthPercent = (gameState.playerBaseHealth / 1000) * 100;
            const enemyHealthPercent = (gameState.enemyBaseHealth / 1000) * 100;
            document.getElementById('playerHealthFill').style.width = `${Math.max(0, Math.min(100, playerHealthPercent))}%`;
            document.getElementById('enemyHealthFill').style.width = `${Math.max(0, Math.min(100, enemyHealthPercent))}%`;
            
            // Change health bar colors based on health percentage
            document.getElementById('playerHealthFill').style.backgroundColor = 
                playerHealthPercent > 60 ? '#33CC33' : 
                playerHealthPercent > 30 ? '#FFCC00' : '#CC3333';
            
            document.getElementById('enemyHealthFill').style.backgroundColor = 
                enemyHealthPercent > 60 ? '#33CC33' : 
                enemyHealthPercent > 30 ? '#FFCC00' : '#CC3333';

            // Update win streaks in the stats panel with dynamic colors
            const playerStreakElem = document.querySelector('.player-header');
            const enemyStreakElem = document.querySelector('.enemy-header');
            
            function getStreakColor(streak) {
                if (streak === 0) return '#FFFFFF';  // White for 0
                if (streak === 1) return '#FFCC00';  // Gold for 1
                if (streak === 2) return '#FF9900';  // Orange for 2
                if (streak === 3) return '#FF6600';  // Dark Orange for 3
                if (streak === 4) return '#FF3300';  // Red-Orange for 4
                return '#FF0000';  // Red for 5+
            }
            
            if (playerStreakElem) {
                const streakColor = getStreakColor(gameState.playerWinStreak);
                playerStreakElem.innerHTML = `Player Stats<span style="color: ${streakColor}; font-size: 0.9em; font-weight: normal;"><br>Win Streak: ${gameState.playerWinStreak}</span>`;
            }
            if (enemyStreakElem) {
                const streakColor = getStreakColor(gameState.enemyWinStreak);
                enemyStreakElem.innerHTML = `Enemy Stats<span style="color: ${streakColor}; font-size: 0.9em; font-weight: normal;"><br>Win Streak: ${gameState.enemyWinStreak}</span>`;
            }
        }

        // Reset game to initial state
        function resetGame() {
            gameState = {
                playerGold: 100,
                enemyGold: 100,
                playerBaseHealth: 1000,
                enemyBaseHealth: 1000,
                playerStagingArea: [],
                enemyStagingArea: [],
                activeUnits: [],
                playerMiners: 0,
                enemyMiners: 0,
                playerVaults: 0,
                enemyVaults: 0,
                goldTimer: GOLD_INTERVAL,
                battleTimer: BATTLE_INTERVAL,
                gameOver: false,
                draggingUnit: null,
                dragStartPos: null,
                playerBaseAttackCooldown: 0,
                enemyBaseAttackCooldown: 0,
                firstBattleOccurred: false,
                animationTimer: 0,
                currentFrame: 0,
                playerWinStreak: 0,
                enemyWinStreak: 0,
                prevPlayerWinStreak: 0,
                prevEnemyWinStreak: 0,
                nextBattleWinBonus: BASE_WIN_BONUS,
                battleWon: false,
                upgrades: {
                    shadowPriest: false,  // Reset Shadow Priest upgrade
                    arcLightning: false,  // Reset Arc Lightning upgrade
                    pillage: false,       // Reset Pillage upgrade
                    poisonArrow: false    // Reset Poison Arrow upgrade
                }
            };
            
            // Reset unit types to default values
            unitTypes.priestess.healAmount = 15;  // Reset to default
            unitTypes.priestess.damage = 5;       // Reset to default
            unitTypes.priestess.baseDamage = 5;   // Reset to default
            
            projectiles = [];
            particles = [];
            baseProjectiles = [];
            updateUI();
            updateMines(); // Always show miner boxes after reset
            updateMinerShopItem();
            updateVaultShopItem();
            updateUpgradeShopItems();  // Reset upgrade shop items
            
            // Reset shop item appearances for upgrades
            const priestessShopItem = document.querySelector('.shop-item[onclick*="priestess"]');
            if (priestessShopItem) {
                const tooltip = priestessShopItem.querySelector('.tooltip');
                if (tooltip) {
                    tooltip.innerHTML = tooltip.innerHTML
                        .replace('Unit Damage: 40 (Magic)', 'Unit Damage: 5 (Magic)')
                        .replace('Base Attack: 10', 'Base Attack: 5')
                        .replace('Heal Amount: 30', 'Heal Amount: 15')
                        .replace('Special: Heals nearby injured allies [Shadow Priest]', 'Special: Heals nearby injured allies [Shadow Priestess]');
                }
                
                // Reset priestess icon in shop to normal appearance
                const emojiSpan = priestessShopItem.querySelector('.shop-item-emoji');
                if (emojiSpan) {
                    const canvas = emojiSpan.querySelector('canvas');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        // Clear and redraw without filter
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.filter = 'none';
                        ctx.drawImage(priestessSprite, 0, 0, 32, 32, 0, 0, 32, 32);
                    }
                }
            }
            
            // Reset shadow priest upgrade item appearance
            const shadowPriestItem = document.querySelector('.shop-item[onclick*="shadowPriest"]');
            if (shadowPriestItem) {
                shadowPriestItem.classList.remove('purchased');
                shadowPriestItem.style.backgroundColor = '';
                shadowPriestItem.style.color = '';
                // Remove the count indicator
                const countIndicator = shadowPriestItem.querySelector('.miner-count');
                if (countIndicator) {
                    countIndicator.remove();
                }
            }
            
            // Reset arc lightning upgrade item appearance
            const arcLightningItem = document.querySelector('.shop-item[onclick*="arcLightning"]');
            if (arcLightningItem) {
                arcLightningItem.classList.remove('purchased');
                arcLightningItem.style.backgroundColor = '';
                arcLightningItem.style.color = '';
                // Remove the count indicator
                const arcCountIndicator = arcLightningItem.querySelector('.miner-count');
                if (arcCountIndicator) {
                    arcCountIndicator.remove();
                }
            }
            
            // Reset pillage upgrade item appearance
            const pillageItem = document.querySelector('.shop-item[onclick*="pillage"]');
            if (pillageItem) {
                pillageItem.classList.remove('purchased');
                pillageItem.style.backgroundColor = '';
                pillageItem.style.color = '';
                // Remove the count indicator
                const pillageCountIndicator = pillageItem.querySelector('.miner-count');
                if (pillageCountIndicator) {
                    pillageCountIndicator.remove();
                }
            }
            
            // Reset poison arrow upgrade item appearance
            const poisonArrowItem = document.querySelector('.shop-item[onclick*="poisonArrow"]');
            if (poisonArrowItem) {
                poisonArrowItem.classList.remove('purchased');
                poisonArrowItem.style.backgroundColor = '';
                poisonArrowItem.style.color = '';
                // Remove the count indicator
                const poisonCountIndicator = poisonArrowItem.querySelector('.miner-count');
                if (poisonCountIndicator) {
                    poisonCountIndicator.remove();
                }
            }
            
            // Reset mage tooltip to remove Arc Lightning reference
            const mageShopItem = document.querySelector('.shop-item[onclick*="mage"]');
            if (mageShopItem) {
                const tooltip = mageShopItem.querySelector('.tooltip');
                if (tooltip) {
                    tooltip.innerHTML = tooltip.innerHTML
                        .replace('Special: Arc Lightning chains to nearby enemies every 3s<br>Special:', 'Special:');
                }
                
                // Reset mage icon in shop to normal appearance
                const emojiSpan = mageShopItem.querySelector('.shop-item-emoji');
                if (emojiSpan) {
                    const canvas = emojiSpan.querySelector('canvas');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        // Clear and redraw without filter and lightning bolt
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.filter = 'none';
                        ctx.drawImage(mageSprite, 0, 0, 32, 32, 0, 0, 32, 32);
                    }
                }
            }
            
            // Update tooltip for miner to show new gold rates
            const minerTooltip = document.querySelector('.shop-item[onclick*="miner"] .tooltip');
            if (minerTooltip) {
                minerTooltip.innerHTML = `
                    ⛏️ Miner<br>
                    Miner 1: 200g (+1 gold/sec)<br>
                    Miner 2: 250g (+2 gold/sec)<br>
                    Miner 3: 300g (+3 gold/sec)<br>
                    Effect: Progressive gold income<br>
                    Non-combat unit
                `;
            }
            
            // Restart game loop
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // Update mouse handling for smoother dragging
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Check if click is in player staging area
            const stagingArea = gameAreas.playerStaging;
            if (isInStagingArea(x, y, stagingArea)) {
                // Find clicked unit
                const clickedUnit = gameState.playerStagingArea.find(unit => {
                    if (!unit || !unit.position) return false;
                    const pos = fromIsoCoords(unit.position.x, unit.position.y, true);
                    const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                    return dist < 30; // Increased hit radius for better detection
                });

                if (clickedUnit) {
                    gameState.draggingUnit = clickedUnit;
                    gameState.dragOriginalPos = { ...clickedUnit.position };
                }
            }
        }

        function handleMouseMove(e) {
            if (!gameState.draggingUnit) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            const stagingArea = gameAreas.playerStaging;
            const isoPos = toIsoCoords(x, y);
            
            // No padding, clamp only to [0, 1] to keep inside area
            isoPos.x = Math.max(0, Math.min(1, isoPos.x));
            isoPos.y = Math.max(0, Math.min(1, isoPos.y));
            gameState.draggingUnit.position = isoPos;
        }

        function handleMouseUp(e) {
            if (!gameState.draggingUnit) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            const stagingArea = gameAreas.playerStaging;
            
            if (!isInStagingArea(x, y, stagingArea)) {
                // Return to original position if dropped outside
                gameState.draggingUnit.position = gameState.dragOriginalPos || { x: 0.5, y: 0.5 };
            } else {
                // Convert screen position to isometric position
                const isoPos = toIsoCoords(x, y);
                
                // Keep within bounds with padding
                const padding = 0.1;
                gameState.draggingUnit.position = {
                    x: Math.min(1 - padding, Math.max(padding, isoPos.x)),
                    y: Math.min(1 - padding, Math.max(padding, isoPos.y))
                };
            }

            // Clear dragging state
            gameState.draggingUnit = null;
            gameState.dragOriginalPos = null;
        }

        // Initialize game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Add mouse event listeners
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);

            // Add shop tooltip positioning
            document.querySelectorAll('.shop-item').forEach(item => {
                item.addEventListener('mousemove', (e) => {
                    const tooltip = item.querySelector('.tooltip');
                    if (tooltip) {
                        const rect = item.getBoundingClientRect();
                        const x = rect.left + rect.width / 2;
                        const y = rect.top;
                        tooltip.style.left = `${x}px`;
                        tooltip.style.top = `${y}px`;
                    }
                });
            });

            // Add section toggle functionality
            document.querySelectorAll('.shop-section-title').forEach(title => {
                title.addEventListener('click', function() {
                    const section = this.parentElement;
                    section.classList.toggle('collapsed');
                });
            });
            
            // Initialize shadow priestess upgrade icon with the tinted sprite
            const shadowPriestItem = document.querySelector('.shop-item[onclick*="shadowPriest"]');
            if (shadowPriestItem) {
                const emojiSpan = shadowPriestItem.querySelector('.shop-item-emoji');
                if (emojiSpan) {
                    // Create a canvas for the upgrade icon
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;
                    canvas.height = 32;
                    canvas.style.display = 'block';
                    canvas.style.margin = '0 auto';
                    const ctx = canvas.getContext('2d');
                    
                    // Load priestess sprite if not already loaded
                    if (!priestessSprite.complete) {
                        priestessSprite.onload = function() {
                            // Apply dark blue tint filter
                            ctx.filter = 'hue-rotate(210deg) saturate(1.2) brightness(0.8)';
                            ctx.drawImage(priestessSprite, 0, 0, 32, 32, 0, 0, 32, 32);
                        };
                    } else {
                        // Apply dark blue tint filter
                        ctx.filter = 'hue-rotate(210deg) saturate(1.2) brightness(0.8)';
                        ctx.drawImage(priestessSprite, 0, 0, 32, 32, 0, 0, 32, 32);
                    }
                    
                    // Replace emoji with canvas
                    emojiSpan.innerHTML = '';
                    emojiSpan.appendChild(canvas);
                    
                    // Also update the tooltip to remove the emoji
                    const tooltip = shadowPriestItem.querySelector('.tooltip');
                    if (tooltip) {
                        tooltip.innerHTML = tooltip.innerHTML.replace('🌑 Shadow Priestess', 'Shadow Priestess');
                    }
                }
            }
        });

        // Update shop tooltips to show damage types and advantages
        document.querySelectorAll('.shop-item').forEach(item => {
            const tooltip = item.querySelector('.tooltip');
            const onclickAttr = item.getAttribute('onclick') || '';
            
            // Skip if there's no onclick attribute
            if (!onclickAttr) return;
            
            // Check if this is a unit or an upgrade
            if (onclickAttr.includes('buyUnit')) {
                const unitType = onclickAttr.match(/buyUnit\('(.+)'\)/)[1];
                const unit = unitTypes[unitType];
                
                if (unit.isMiner) {
                    const costs = unit.cost.map((cost, index) => `Miner ${index + 1}: ${cost}g (+${unit.goldRates[index]} gold/sec)`).join('<br>');
                    tooltip.innerHTML = `
                        ${unit.emoji} ${unit.name}<br>
                        ${costs}<br>
                        Effect: Upgrades passive gold income<br>
                        Non-combat unit
                    `;
                } else if (unit.isVault) {
                    const maxGoldIncrease = unit.maxGoldIncrease.map((increase, index) => `Vault ${index + 1}: +${increase} max gold`).join('<br>');
                    tooltip.innerHTML = `
                        ${unit.emoji} ${unit.name}<br>
                        ${maxGoldIncrease}<br>
                        Effect: Increases max gold capacity<br>
                        Non-combat unit
                    `;
                } else {
                    // Get damage type effectiveness information
                    const damageType = unit.damageType;
                    const effectiveness = DAMAGE_TYPE_EFFECTIVENESS[damageType];
                    let effectivenessText = '<br>Damage Effectiveness:<br>';
                    
                    // Add effectiveness against each armor type
                    Object.entries(effectiveness).forEach(([armorType, multiplier]) => {
                        const effectiveness = multiplier > 1 ? 'Strong' : multiplier < 1 ? 'Weak' : 'Neutral';
                        const color = multiplier > 1 ? '#88ff88' : multiplier < 1 ? '#ff8888' : '#ffffff';
                        effectivenessText += `<span style="color:${color}">${effectiveness} vs ${armorType} Armor</span><br>`;
                    });
                    
                    // Special handling for priestess
                    if (unitType === 'priestess') {
                        tooltip.innerHTML = `
                            ${unit.name}<br>
                            Health: ${unit.health}<br>
                            Unit Damage: ${unit.damage} (${unit.damageType})<br>
                            Base Attack: ${unit.baseDamage}<br>
                            Attack Speed: ${unit.attackSpeed}/s<br>
                            Move Speed: ${unit.moveSpeed}x<br>
                            Range: ${unit.ranged ? 'Long' : 'Melee'}<br>
                            Armor: ${unit.armorType}<br>
                            Attack Type: ${unit.damageType}<br>
                            Heal Amount: ${unit.healAmount}<br>
                            Heal Range: ${unit.healRange}<br>
                            Heal Speed: ${unit.healSpeed}/s<br>
                            Special: Heals nearby injured allies<br>
                            ${effectivenessText}
                        `;
                    } else {
                        tooltip.innerHTML = `
                            ${unit.name}<br>
                            Health: ${unit.health}<br>
                            Unit Damage: ${unit.damage} (${unit.damageType})<br>
                            Base Attack: ${unit.baseDamage}<br>
                            Attack Speed: ${unit.attackSpeed}/s<br>
                            Move Speed: ${unit.moveSpeed}x<br>
                            Range: ${unit.ranged ? 'Long' : 'Melee'}<br>
                            Armor: ${unit.armorType}<br>
                            Attack Type: ${unit.damageType}<br>
                            ${effectivenessText}
                        `;
                    }
                }
            }
            // Upgrades are handled separately in their HTML definition
        });

        // Add sprite animation update function
        function updateAnimations(deltaTime) {
            gameState.animationTimer += deltaTime;
            const frameDuration = 1 / ANIMATION_FPS;
            
            if (gameState.animationTimer >= frameDuration) {
                // Update frame counters for each unit type
                ['warrior', 'archer', 'mage'].forEach(type => {
                    if (SPRITE_FRAMES[type] > 1) {
                        gameState.currentFrame = (gameState.currentFrame + 1) % SPRITE_FRAMES[type];
                    }
                });
                
                gameState.animationTimer = gameState.animationTimer % frameDuration;
            }
        }

        // Add attribution comment
        /*
         * King sprite from "Lively NPCs" by chierit
         * Source: https://chierit.itch.io/lively-npcs
         * License: Creative Commons Attribution v4.0 International
         */

        // Update shop display to use sprites
        const shopItems = document.querySelectorAll('.shop-item');
        shopItems.forEach(item => {
            const onclickAttr = item.getAttribute('onclick') || '';
            
            // Skip if there's no onclick attribute
            if (!onclickAttr) return;
            
            // Handle both unit items and upgrades
            if (onclickAttr.includes('buyUnit')) {
                const unitType = onclickAttr.match(/buyUnit\('(.+)'\)/)[1];
                
                if (unitType === 'warrior' || unitType === 'archer' || unitType === 'mage' || unitType === 'priestess') {
                    const emojiSpan = item.querySelector('.shop-item-emoji');
                    if (emojiSpan) {
                        // Create a canvas for the shop icon
                        const canvas = document.createElement('canvas');
                        canvas.width = 32;
                        canvas.height = 32;
                        canvas.style.display = 'block';
                        canvas.style.margin = '0 auto';
                        const ctx = canvas.getContext('2d');
                        
                        // Select the appropriate sprite
                        let sprite;
                        if (unitType === 'warrior') sprite = warriorSprite;
                        else if (unitType === 'archer') sprite = archerSprite;
                        else if (unitType === 'mage') sprite = mageSprite;
                        else if (unitType === 'priestess') sprite = priestessSprite;
                        
                        // Draw the sprite when it's loaded
                        sprite.addEventListener('load', () => {
                            // Check if this is a priestess and shadow priest upgrade is active
                            if (unitType === 'priestess' && gameState.upgrades && gameState.upgrades.shadowPriest) {
                                ctx.filter = 'hue-rotate(210deg) saturate(1.2) brightness(0.8)';
                            }
                            ctx.drawImage(sprite, 0, 0, 32, 32, 0, 0, 32, 32);
                        });
                        
                        // Replace emoji with canvas
                        emojiSpan.innerHTML = '';
                        emojiSpan.appendChild(canvas);
                    }

                    // Also update the tooltip to remove the emoji
                    const tooltip = item.querySelector('.tooltip');
                    if (tooltip) {
                        const tooltipContent = tooltip.innerHTML;
                        const emoji = unitTypes[unitType].emoji;
                        tooltip.innerHTML = tooltipContent.replace(emoji, '');
                    }
                }
            } else if (onclickAttr.includes('buyUpgrade')) {
                // Handle upgrade items (specifically for Shadow Priestess)
                const upgradeType = onclickAttr.match(/buyUpgrade\('(.+)'\)/)[1];
                
                if (upgradeType === 'shadowPriest') {
                    const emojiSpan = item.querySelector('.shop-item-emoji');
                    if (emojiSpan && priestessSprite.complete) {
                        // Create a canvas for the shop icon
                        const canvas = document.createElement('canvas');
                        canvas.width = 32;
                        canvas.height = 32;
                        canvas.style.display = 'block';
                        canvas.style.margin = '0 auto';
                        const ctx = canvas.getContext('2d');
                        
                        // Draw priestess with dark blue tint
                        ctx.filter = 'hue-rotate(210deg) saturate(1.2) brightness(0.8)';
                        ctx.drawImage(priestessSprite, 0, 0, 32, 32, 0, 0, 32, 32);
                        
                        // Replace emoji with canvas
                        emojiSpan.innerHTML = '';
                        emojiSpan.appendChild(canvas);
                    }
                }
            }
        });

        // --- START SCREEN & TUTORIAL LOGIC ---
        const startScreen = document.getElementById('startScreen');
        const tutorialOverlay = document.getElementById('tutorialOverlay');
        const startGameBtn = document.getElementById('startGameBtn');
        const howToPlayBtn = document.getElementById('howToPlayBtn');
        const closeTutorialBtn = document.getElementById('closeTutorialBtn');
        // Hide loading screen and game UI until game starts
        document.querySelector('.ui-container').style.display = 'none';
        document.querySelector('.stats-panel').style.display = 'none';
        document.querySelector('.shop-container').style.display = 'none';
        document.getElementById('loadingScreen').style.display = 'none';
        // Show tutorial overlay
        howToPlayBtn.addEventListener('click', () => {
            tutorialOverlay.style.display = 'flex';
        });
        closeTutorialBtn.addEventListener('click', () => {
            tutorialOverlay.style.display = 'none';
        });
        // Start game button logic
        startGameBtn.addEventListener('click', () => {
            startScreen.style.display = 'none';
            document.querySelector('.ui-container').style.display = '';
            document.querySelector('.stats-panel').style.display = '';
            document.querySelector('.shop-container').style.display = '';
            document.getElementById('loadingScreen').style.display = '';
            // Actually start the game loading process
            initGame();
        });
        // Prevent game from auto-initializing before start
        window.addEventListener('DOMContentLoaded', () => {
            // Do not call initGame() here; wait for Start Game button
            // Do not add mouse event listeners here
        });
        // --- END SCREEN & TUTORIAL LOGIC ---

        // Add healing particle class
        class HealingParticle {
            constructor(x, y, amount, isShadowPriest = false) {
                this.x = x;
                this.y = y;
                this.amount = amount;
                this.life = 1.0;  // 1 second lifetime
                this.dy = -30;  // Move upward
                this.fontSize = 16;
                this.particles = [];  // Store healing effect particles
                this.isShadowPriest = isShadowPriest;
                
                // Create healing effect particles
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    this.particles.push({
                        x: 0,
                        y: 0,
                        angle: angle,
                        speed: 1 + Math.random() * 2,
                        life: 1.0
                    });
                }
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                this.dy += 60 * deltaTime;  // Gravity effect
                this.y += this.dy * deltaTime;
                
                // Update healing effect particles
                this.particles.forEach(p => {
                    p.life -= deltaTime;
                    p.x += Math.cos(p.angle) * p.speed;
                    p.y += Math.sin(p.angle) * p.speed;
                });
                
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save();
                
                // Draw healing effect particles
                ctx.globalAlpha = Math.min(1, this.life * 2) * 0.5;
                // Use blue for shadow priestess, green for regular
                ctx.fillStyle = this.isShadowPriest ? '#9966FF' : '#00FF00';
                this.particles.forEach(p => {
                    if (p.life > 0) {
                        ctx.beginPath();
                        ctx.arc(
                            this.x + p.x,
                            this.y + p.y,
                            2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                });
                
                // Draw healing number
                ctx.globalAlpha = Math.min(1, this.life * 2);
                ctx.font = `bold ${this.fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                // Use blue for shadow priest, green for regular
                ctx.fillStyle = this.isShadowPriest ? '#9966FF' : '#00FF00';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeText(`+${this.amount}`, this.x, this.y);
                ctx.fillText(`+${this.amount}`, this.x, this.y);
                
                ctx.restore();
            }
        }

        // Add the showVictoryPopup function before the gameLoop function
        function showVictoryPopup(isPlayerWin, goldAwarded, streak, prevStreak) {
            const popup = document.querySelector('.victory-popup');
            const goldSpan = document.getElementById('victoryGold');
            const streakSpan = document.getElementById('victoryStreak');
            const streakLabel = document.getElementById('streakLabel');
            const goldPrefix = document.getElementById('goldPrefix');
            const goldSuffix = document.getElementById('goldSuffix');
            
            // Check if this is a broken streak (previous streak was > 0 and now is 1)
            const isBrokenStreak = isPlayerWin ? 
                (gameState.prevEnemyWinStreak > 0 && streak === 1) : 
                (gameState.prevPlayerWinStreak > 0 && streak === 1);
            
            // Always use the actual awarded gold amount
            const displayGold = goldAwarded;
            
            // Update popup content
            if (isBrokenStreak) {
                popup.querySelector('h2').textContent = 'Broken Streak!';
                goldSpan.textContent = displayGold;
                // Hide streak display for broken streaks
                const streakDiv = popup.querySelector('.streak');
                if (streakDiv) {
                    streakDiv.style.display = 'none';
                }
                
                // Update gold display for broken streak
                if (isPlayerWin) {
                    goldPrefix.textContent = 'Awarded ';
                    goldSuffix.textContent = ' gold';
                } else {
                    goldPrefix.textContent = 'Enemy awarded ';
                    goldSuffix.textContent = ' gold';
                }
            } else {
                popup.querySelector('h2').textContent = isPlayerWin ? 'Victory!' : 'Defeat!';
                goldSpan.textContent = displayGold;
                // Show streak display for regular victories
                const streakDiv = popup.querySelector('.streak');
                if (streakDiv) {
                    streakDiv.style.display = '';
                }
                streakSpan.textContent = streak;
                streakLabel.textContent = isPlayerWin ? 'Player Win Streak' : 'Enemy Win Streak';
                
                // Update gold display based on who won
                if (isPlayerWin) {
                    goldPrefix.textContent = '+';
                    goldSuffix.textContent = ' gold';
                } else {
                    goldPrefix.textContent = 'Enemy gained ';
                    goldSuffix.textContent = ' gold';
                }
            }
            
            // Set appropriate class
            popup.className = 'victory-popup';
            popup.classList.add(isPlayerWin ? 'player-win' : 'enemy-win');
            popup.classList.add('show');
            
            // Log the values for debugging
            console.log('Popup values:', {
                isPlayerWin,
                goldAwarded,
                displayGold,
                streak,
                prevStreak,
                isBrokenStreak,
                goldSpanText: goldSpan.textContent
            });
            
            // Hide popup after 3 seconds
            setTimeout(() => {
                popup.classList.remove('show');
            }, 3000);
        }

        // --- STEP-BY-STEP TUTORIAL LOGIC ---
        const tutorialSteps = [
          // 1. Enemy Base (centered)
          {
            left: '74%', top: '1%', width: '12%', height: '22%',
            label: 'Enemy Base',
            text: 'This is the enemy base. The goal is to destroy it before yours is destroyed!'
          },
          // 2. Player Base (centered)
          {
            left: '10%', top: '65%', width: '12%', height: '22%',
            label: 'Your Base',
            text: 'This is your base. Defend it from enemy attacks!'
          },
          // 3. Stats (Player & Enemy)
          {
            left: '0%', top: '0%', width: '17%', height: '55%',
            label: 'Player & Enemy Stats',
            text: 'Here you can see your stats and the enemy\'s stats, including current gold, win streak, base HP, and economy upgrades.'
          },
          // 4. Shop (extended left)
          {
            left: '68%', top: '70%', width: '30%', height: '26%',
            label: 'Shop',
            text: 'Buy combat units and economy upgrades here. Mouseover units or upgrades for details.'
          },
          // 5. Staging Area (bottom left, oval)
          {
            left: '13%', top: '54%', width: '28%', height: '28%', borderRadius: '40% 40% 60% 60%/60% 60% 40% 40%',
            label: 'Staging Area',
            text: 'Arrange your army here before each round. Drag to reposition units!'
          },
          // 6. Battle Timer (smaller)
          {
            left: '43%', top: '1%', width: '12%', height: '10%',
            label: 'Next Battle Counter',
            text: 'This shows when the next battle will start and the win bonus. Win streaks increase the bonus!'
          }
        ];
        let tutorialStep = 0;
        const highlight = document.getElementById('tutorialHighlight');
        const label = document.getElementById('tutorialLabel');
        const img = document.getElementById('tutorialImage');
        const prevBtn = document.getElementById('tutorialPrevBtn');
        const nextBtn = document.getElementById('tutorialNextBtn');
        function showTutorialStep(idx) {
          const step = tutorialSteps[idx];
          if (!step) return;
          highlight.style.display = 'block';
          label.style.display = 'block';
          highlight.style.left = step.left;
          highlight.style.top = step.top;
          highlight.style.width = step.width;
          highlight.style.height = step.height;
          highlight.classList.toggle('staging', !!step.borderRadius);
          if (step.borderRadius) {
            highlight.style.borderRadius = step.borderRadius;
          } else {
            highlight.style.borderRadius = '12px';
          }
          label.innerHTML = `<b>${step.label}</b><br><span style='font-size:0.98em;'>${step.text}</span>`;
          // Position label smartly (right or left of highlight, or below if near right edge)
          const leftNum = parseFloat(step.left);
          if (leftNum > 60) {
            label.style.left = 'auto';
            label.style.right = '2%';
            label.style.top = `calc(${step.top} + ${step.height} + 10px)`;
          } else {
            label.style.left = `calc(${step.left} + ${step.width} + 12px)`;
            label.style.right = 'auto';
            label.style.top = step.top;
          }
          // Hide prev/next if at ends
          prevBtn.disabled = idx === 0;
          nextBtn.textContent = idx === tutorialSteps.length - 1 ? 'Finish' : 'Next';
        }
        prevBtn.onclick = () => {
          if (tutorialStep > 0) {
            tutorialStep--;
            showTutorialStep(tutorialStep);
          }
        };
        nextBtn.onclick = () => {
          if (tutorialStep < tutorialSteps.length - 1) {
            tutorialStep++;
            showTutorialStep(tutorialStep);
          } else {
            document.getElementById('tutorialOverlay').style.display = 'none';
          }
        };
        // Show first step when overlay opens
        document.getElementById('howToPlayBtn').onclick = function() {
          document.getElementById('tutorialOverlay').style.display = 'flex';
          tutorialStep = 0;
          showTutorialStep(0);
        };
        document.getElementById('closeTutorialBtn').onclick = function() {
          document.getElementById('tutorialOverlay').style.display = 'none';
        };

        // Function to buy upgrades
        function buyUpgrade(upgradeType) {
            let cost;
            
            // Set cost based on upgrade type
            switch (upgradeType) {
                case 'shadowPriest':
                    cost = 150;
                    break;
                case 'arcLightning':
                    cost = 200;
                    break;
                case 'pillage':
                    cost = 175;
                    break;
                case 'poisonArrow':
                    cost = 150;
                    break;
                default:
                    return; // Unknown upgrade
            }
            
            // Check if player can afford the upgrade
            if (gameState.playerGold >= cost) {
                // Check if upgrade is already purchased
                if (gameState.upgrades[upgradeType]) {
                    return; // Already purchased
                }
                
                // Purchase the upgrade
                gameState.playerGold -= cost;
                gameState.upgrades[upgradeType] = true;
                
                // Apply upgrade effects
                applyUpgradeEffects(upgradeType);
                
                // Update UI
                updateUI();
                
                // Update shop item to show purchased
                updateUpgradeShopItems();
                
                // Force a redraw to refresh all units with new appearance
                draw();
            }
        }
        
        // Function to apply upgrade effects
        function applyUpgradeEffects(upgradeType) {
            switch (upgradeType) {
                case 'shadowPriest':
                    // Upgrade priestess stats
                    unitTypes.priestess.healAmount = 30;  // Increase from 15
                    unitTypes.priestess.damage = 40;      // Increase from 5
                    unitTypes.priestess.baseDamage = 10;  // Increase from 5
                    
                    console.log("Applying Shadow Priestess upgrade to existing units");
                    
                    // Update existing priestesses in staging area
                    gameState.playerStagingArea.forEach(unit => {
                        if (unit.type === 'priestess') {
                            console.log("Upgrading priestess in staging area to shadow priestess");
                            unit.isShadowPriest = true;
                            unit.healAmount = 30;
                            unit.damage = 40;
                            unit.baseDamage = 10;
                        }
                    });
                    
                    // Logging units after the upgrade for debugging
                    console.log("Player staging area after upgrade:", 
                        gameState.playerStagingArea.map(u => {
                            if (u.type === 'priestess') {
                                return {type: u.type, isShadowPriest: u.isShadowPriest};
                            }
                            return u.type;
                        })
                    );
                    
                    // Update existing priestesses in active units
                    gameState.activeUnits.forEach(unit => {
                        if (unit.type === 'priestess' && unit.isPlayer) {
                            console.log("Upgrading active priestess to shadow priestess");
                            unit.healAmount = 30;
                            unit.damage = 40;
                            unit.baseDamage = 10;
                            unit.isShadowPriest = true;
                        }
                    });
                    
                    // Update priestess tooltip in shop
                    const priestessShopItem = document.querySelector('.shop-item[onclick*="priestess"]');
                    if (priestessShopItem) {
                        const tooltip = priestessShopItem.querySelector('.tooltip');
                        if (tooltip) {
                            tooltip.innerHTML = tooltip.innerHTML
                                .replace('Health: 250', 'Health: 250')
                                .replace('Unit Damage: 5 (Magic)', 'Unit Damage: 40 (Magic) [Shadow]')
                                .replace('Base Attack: 5', 'Base Attack: 10')
                                .replace('Heal Amount: 15', 'Heal Amount: 30')
                                .replace('Special: Heals nearby injured allies', 'Special: Heals nearby injured allies [Shadow Priestess]');
                        }
                        
                        // Apply dark blue tint to the priestess icon in shop
                        const emojiSpan = priestessShopItem.querySelector('.shop-item-emoji');
                        if (emojiSpan) {
                            const canvas = emojiSpan.querySelector('canvas');
                            if (canvas) {
                                const ctx = canvas.getContext('2d');
                                // Clear and redraw with dark blue tint
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.filter = 'hue-rotate(210deg) saturate(1.2) brightness(0.8)';
                                ctx.drawImage(priestessSprite, 0, 0, 32, 32, 0, 0, 32, 32);
                            }
                        }
                    }
                    
                    // Update the Shadow Priestess icon in upgrades shop section
                    const shadowPriestItem = document.querySelector('.shop-item[onclick*="shadowPriest"]');
                    if (shadowPriestItem) {
                        const emojiSpan = shadowPriestItem.querySelector('.shop-item-emoji');
                        if (emojiSpan) {
                            // Create a canvas for the shop icon if it doesn't exist
                            let canvas = emojiSpan.querySelector('canvas');
                            if (!canvas) {
                                canvas = document.createElement('canvas');
                                canvas.width = 32;
                                canvas.height = 32;
                                canvas.style.display = 'block';
                                canvas.style.margin = '0 auto';
                                emojiSpan.innerHTML = '';
                                emojiSpan.appendChild(canvas);
                            }
                            
                            const ctx = canvas.getContext('2d');
                            // Draw priestess with dark blue tint
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.filter = 'hue-rotate(210deg) saturate(1.2) brightness(0.8)';
                            ctx.drawImage(priestessSprite, 0, 0, 32, 32, 0, 0, 32, 32);
                        }
                    }
                    
                    // Force a redraw to ensure priestesses get the shadow effect
                    draw();
                    
                    break;
                    
                case 'arcLightning':
                    console.log("Applying Arc Lightning upgrade to existing units");
                    
                    // Update existing mages in staging area
                    gameState.playerStagingArea.forEach(unit => {
                        if (unit.type === 'mage') {
                            console.log("Upgrading mage in staging area with Arc Lightning");
                            unit.hasArcLightning = true;
                            unit.arcLightningInterval = 3;
                            unit.arcLightningCooldown = 0;
                        }
                    });
                    
                    // Update existing mages in active units
                    gameState.activeUnits.forEach(unit => {
                        if (unit.type === 'mage' && unit.isPlayer) {
                            console.log("Upgrading active mage with Arc Lightning");
                            unit.hasArcLightning = true;
                            unit.arcLightningInterval = 3;
                            unit.arcLightningCooldown = 0;
                        }
                    });
                    
                    // Update mage tooltip in shop
                    const mageShopItem = document.querySelector('.shop-item[onclick*="mage"]');
                    if (mageShopItem) {
                        const tooltip = mageShopItem.querySelector('.tooltip');
                        if (tooltip) {
                            tooltip.innerHTML = tooltip.innerHTML
                                .replace('Special:', 'Special: Arc Lightning chains to nearby enemies every 3s<br>Special:');
                        }
                        
                        // Apply lightning effect to the mage icon in shop
                        const emojiSpan = mageShopItem.querySelector('.shop-item-emoji');
                        if (emojiSpan) {
                            const canvas = emojiSpan.querySelector('canvas');
                            if (canvas) {
                                const ctx = canvas.getContext('2d');
                                // Clear and redraw with lightning effect
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.filter = 'brightness(1.2) saturate(1.5) contrast(1.2)';
                                ctx.drawImage(mageSprite, 0, 0, 32, 32, 0, 0, 32, 32);
                                
                                // Add small lightning bolt
                                ctx.font = '12px Arial';
                                ctx.fillStyle = '#FFFF00';
                                ctx.fillText('⚡', 22, 10);
                            }
                        }
                    }
                    
                    // Update the Arc Lightning icon in upgrades shop section
                    const arcLightningItem = document.querySelector('.shop-item[onclick*="arcLightning"]');
                    if (arcLightningItem) {
                        // Highlight the item as purchased
                        arcLightningItem.classList.add('purchased');
                    }
                    
                    // Force a redraw to ensure mages get the arc lightning effect
                    draw();
                    
                    break;
                    
                case 'pillage':
                    console.log("Applying Pillage upgrade to existing units");
                    
                    // Update existing warriors in staging area
                    gameState.playerStagingArea.forEach(unit => {
                        if (unit.type === 'warrior') {
                            console.log("Upgrading warrior in staging area with Pillage");
                            unit.hasPillage = true;
                            unit.pillageCooldown = 0;
                        }
                    });
                    
                    // Update existing warriors in active units
                    gameState.activeUnits.forEach(unit => {
                        if (unit.type === 'warrior' && unit.isPlayer) {
                            console.log("Upgrading active warrior with Pillage");
                            unit.hasPillage = true;
                            unit.pillageCooldown = 0;
                        }
                    });
                    
                    // Update warrior tooltip in shop
                    const warriorShopItem = document.querySelector('.shop-item[onclick*="warrior"]');
                    if (warriorShopItem) {
                        const tooltip = warriorShopItem.querySelector('.tooltip');
                        if (tooltip) {
                            tooltip.innerHTML = tooltip.innerHTML
                                .replace('Health: 450', 'Health: 450')
                                .replace('Unit Damage: 20 (Physical)', 'Unit Damage: 20 (Physical) [Pillage]')
                                .replace('Base Attack: 10', 'Base Attack: 10')
                                .replace('Attack Speed: 1.5/s', 'Attack Speed: 1.5/s')
                                .replace('Move Speed: 1.2x', 'Move Speed: 1.2x')
                                .replace('Range: Melee', 'Range: Melee')
                                .replace('Armor: Heavy', 'Armor: Heavy')
                                .replace('Attack Type: Physical', 'Attack Type: Physical')
                                .replace('Damage Bonuses:', 'Damage Bonuses:');
                        }
                    }
                    
                    // Update the Pillage icon in upgrades shop section
                    const pillageItem = document.querySelector('.shop-item[onclick*="pillage"]');
                    if (pillageItem) {
                        // Highlight the item as purchased
                        pillageItem.classList.add('purchased');
                        
                    
                    }
                    
                    // Force a redraw to ensure warriors get the pillage effect
                    draw();
                    
                    break;
                    
                case 'poisonArrow':
                    console.log("Applying Poison Arrow upgrade to existing units");
                    
                    // Update existing archers in staging area
                    gameState.playerStagingArea.forEach(unit => {
                        if (unit.type === 'archer') {
                            console.log("Upgrading archer in staging area with Poison Arrow");
                            unit.hasPoisonArrow = true;
                        }
                    });
                    
                    // Update existing archers in active units
                    gameState.activeUnits.forEach(unit => {
                        if (unit.type === 'archer' && unit.isPlayer) {
                            console.log("Upgrading active archer with Poison Arrow");
                            unit.hasPoisonArrow = true;
                        }
                    });
                    
                    // Update archer tooltip in shop
                    const archerShopItem = document.querySelector('.shop-item[onclick*="archer"]');
                    if (archerShopItem) {
                        const tooltip = archerShopItem.querySelector('.tooltip');
                        if (tooltip) {
                            tooltip.innerHTML = tooltip.innerHTML
                                .replace('Unit Damage: 30 (Piercing)', 'Unit Damage: 30 (Piercing) [Poison]')
                                .replace('Special:', 'Special: Applies poison effect that slows targets by 50%<br>Special:');
                        }
                        
                        // Apply poison tint to the archer icon in shop
                        const emojiSpan = archerShopItem.querySelector('.shop-item-emoji');
                        if (emojiSpan) {
                            const canvas = emojiSpan.querySelector('canvas');
                            if (canvas) {
                                const ctx = canvas.getContext('2d');
                                // Clear and redraw with poison tint
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.filter = 'hue-rotate(70deg) saturate(1.5) brightness(0.9)';
                                ctx.drawImage(archerSprite, 0, 0, 32, 32, 0, 0, 32, 32);
                                
                                // Add small poison flask
                                ctx.font = '12px Arial';
                                ctx.fillStyle = '#22AA22';
                                ctx.fillText('🧪', 22, 10);
                            }
                        }
                    }
                    
                    // Update the Poison Arrow icon in upgrades shop section
                    const poisonArrowItem = document.querySelector('.shop-item[onclick*="poisonArrow"]');
                    if (poisonArrowItem) {
                        // Highlight the item as purchased
                        poisonArrowItem.classList.add('purchased');
                    }
                    
                    // Force a redraw to ensure archers get the poison arrow effect
                    draw();
                    
                    break;
            }
        }
        
        // Update upgrade shop items to show purchased state
        function updateUpgradeShopItems() {
            Object.keys(gameState.upgrades).forEach(upgradeType => {
                if (gameState.upgrades[upgradeType]) {
                    const upgradeItem = document.querySelector(`.shop-item[onclick*="${upgradeType}"]`);
                    if (upgradeItem) {
                        // Add a count indicator like miners/vaults instead of changing the whole style
                        let countIndicator = upgradeItem.querySelector('.miner-count');
                        if (!countIndicator) {
                            countIndicator = document.createElement('div');
                            countIndicator.className = 'miner-count';
                            upgradeItem.appendChild(countIndicator);
                        }
                        countIndicator.textContent = '1/1';
                        
                        // Keep the original price text
                        upgradeItem.classList.add('purchased');
                    }
                }
            });
        }

        // Function to trigger Arc Lightning effect
        function triggerArcLightning(mageUnit, targetUnit) {
            // Find all nearby enemies within range
            const chainRange = 150; // Lightning chain range
            const nearbyEnemies = gameState.activeUnits.filter(unit => 
                unit.isPlayer !== mageUnit.isPlayer && 
                unit.health > 0 && 
                unit !== targetUnit &&
                distance(targetUnit, unit) <= chainRange
            );
            
            if (nearbyEnemies.length === 0) return; // No additional targets
            
            // Calculate chain damage (50% of primary damage)
            const chainDamage = Math.round(calculateDamage(mageUnit, targetUnit) * 0.5);
            
            // Sort enemies by distance to create more natural chaining
            nearbyEnemies.sort((a, b) => {
                return distance(targetUnit, a) - distance(targetUnit, b);
            });
            
            // Visual effect for the primary target (arc source)
            particles.push(new LightningFlashParticle(targetUnit.x, targetUnit.y, true));
            
            // Create arc lightning effect to each nearby enemy with delay
            nearbyEnemies.forEach((enemy, index) => {
                // Use setTimeout to create a delay between each chain
                setTimeout(() => {
                    // Only proceed if the game is still running and the enemy is still alive
                    if (!gameState.gameOver && enemy && enemy.health > 0) {
                        // Create a special arc lightning projectile
                        const arcProjectile = {
                            x: targetUnit.x, // Start from the primary target
                            y: targetUnit.y,
                            targetX: enemy.x,
                            targetY: enemy.y,
                            target: enemy,
                            speed: 6 * (canvas.width / 800), // Slower speed for better visibility
                            damage: chainDamage,
                            fromPlayer: mageUnit.isPlayer,
                            damageType: mageUnit.damageType,
                            color: '#66CCFF', // Light blue for arc lightning
                            emoji: '⚡',
                            isArcLightning: true,
                            tracer: true // Enable tracer effect
                        };
                        
                        projectiles.push(arcProjectile);
                    }
                }, 150 * index); // 150ms delay between each chain
            });
        }

        // Add a new particle class for lightning tracers
        class LightningTracerParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 0.3; // Short lifetime
                this.maxLife = 0.3;
                this.size = 3 + Math.random() * 3;
                this.color = `hsl(210, 100%, ${60 + Math.random() * 40}%)`;
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save();
                
                // Fade out as life decreases
                const opacity = (this.life / this.maxLife) * 0.6;
                
                // Draw a glowing circle
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = opacity;
                ctx.fill();
                
                // Add a glow effect
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                
                ctx.restore();
            }
        }

        // Update the LightningFlashParticle class to have more visual impact
        class LightningFlashParticle {
            constructor(x, y, isCaster = false) {
                this.x = x;
                this.y = y;
                this.isCaster = isCaster;
                this.life = isCaster ? 0.6 : 0.4; // Longer flash for source
                this.maxLife = this.life;
                this.radius = isCaster ? 45 : 35;
                this.color = isCaster ? '#FFFFFF' : '#66CCFF';
                
                // Create branching lightning for visual effect
                this.branches = [];
                if (isCaster) {
                    const numBranches = 4 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < numBranches; i++) {
                        this.branches.push({
                            angle: Math.random() * Math.PI * 2,
                            length: 30 + Math.random() * 20,
                            segments: 3 + Math.floor(Math.random() * 3)
                        });
                    }
                }
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save();
                
                // Create a gradient
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius
                );
                
                // Adjust opacity based on remaining life
                const opacity = Math.min(1, this.life * 3);
                
                gradient.addColorStop(0, `${this.color}FF`);
                gradient.addColorStop(0.7, `${this.color}88`);
                gradient.addColorStop(1, `${this.color}00`);
                
                ctx.globalAlpha = opacity;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw lightning branches if this is a caster/source
                if (this.branches.length > 0) {
                    ctx.strokeStyle = '#66FFFF';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#00FFFF';
                    ctx.shadowBlur = 10;
                    
                    for (const branch of this.branches) {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        
                        let lastX = this.x;
                        let lastY = this.y;
                        
                        // Create a jagged lightning branch
                        for (let i = 0; i < branch.segments; i++) {
                            const segmentLength = branch.length / branch.segments;
                            const angle = branch.angle + (Math.random() * 0.8 - 0.4);
                            
                            lastX += Math.cos(angle) * segmentLength;
                            lastY += Math.sin(angle) * segmentLength;
                            
                            ctx.lineTo(lastX, lastY);
                        }
                        
                        ctx.stroke();
                    }
                }
                
                // Draw lightning bolt symbol
                ctx.font = this.isCaster ? '32px Arial' : '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#FFFF00';
                ctx.fillText('⚡', this.x, this.y);
                
                ctx.restore();
            }
        }

        // Add gold particle class
        class GoldParticle {
            constructor(x, y, amount, isPlayer) {
                this.x = x;
                this.y = y;
                this.amount = amount;
                this.isPlayer = isPlayer;
                this.life = 1.5;  // 1.5 second lifetime (increased from 1.0)
                this.dy = -40;  // Move upward
                this.dx = isPlayer ? 10 : -10; // Slight horizontal movement based on player/enemy
                this.fontSize = 16;
                this.glitter = []; // Add glitter effect
                
                // Create glitter particles
                for (let i = 0; i < 8; i++) {
                    this.glitter.push({
                        x: Math.random() * 20 - 10,
                        y: Math.random() * 20 - 10,
                        size: 1 + Math.random() * 2,
                        opacity: 0.5 + Math.random() * 0.5
                    });
                }
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                this.dy += 60 * deltaTime;  // Gravity effect
                this.y += this.dy * deltaTime;
                this.x += this.dx * deltaTime; // Horizontal movement
                
                // Update glitter particles
                this.glitter.forEach(g => {
                    g.opacity -= deltaTime * 0.5;
                });
                
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save();
                
                // Draw glitter particles
                this.glitter.forEach(g => {
                    if (g.opacity > 0) {
                        ctx.fillStyle = `rgba(255, 215, 0, ${g.opacity})`;
                        ctx.beginPath();
                        ctx.arc(this.x + g.x, this.y + g.y, g.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                // Draw gold coin background for better visibility
                ctx.beginPath();
                ctx.arc(this.x, this.y - 10, 12, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.fill();
                
                // Draw gold amount with clear visibility
                ctx.font = `bold ${this.fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#FFCC00';  // Gold color
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                const text = this.isPlayer ? `+${this.amount}g` : `-${this.amount}g`;
                ctx.strokeText(text, this.x, this.y);
                ctx.fillText(text, this.x, this.y);
                
                // Draw gold coin emoji with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.font = '16px Arial';
                ctx.fillText('💰', this.x, this.y - 20);
                
                ctx.restore();
            }
        }

        // Add poison effect particle class
        class PoisonEffectParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1.5;  // 1.5 seconds lifetime
                this.maxLife = 1.5;
                this.particles = [];
                
                // Create multiple poison particles in a cloud
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 5 + Math.random() * 15;
                    this.particles.push({
                        x: Math.cos(angle) * distance,
                        y: Math.sin(angle) * distance,
                        size: 2 + Math.random() * 3,
                        speed: 0.3 + Math.random() * 0.3,
                        angle: angle,
                        alpha: 0.6 + Math.random() * 0.4
                    });
                }
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                
                // Update individual particles
                this.particles.forEach(p => {
                    p.x += Math.cos(p.angle) * p.speed;
                    p.y += Math.sin(p.angle) * p.speed;
                    p.size -= deltaTime * 0.5;  // Shrink over time
                });
                
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save();
                
                // Draw poison emoji
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = Math.min(1, this.life);
                ctx.fillText('🧪', this.x, this.y - 20);
                
                // Draw poison cloud particles
                ctx.globalAlpha = Math.min(1, this.life * 0.8);
                this.particles.forEach(p => {
                    if (p.size > 0) {
                        ctx.beginPath();
                        ctx.arc(this.x + p.x, this.y + p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(0, 180, 0, ${p.alpha * (this.life / this.maxLife)})`;
                        ctx.fill();
                    }
                });
                
                ctx.restore();
            }
        }

        // Function to apply poison effect to units (for Poison Arrow upgrade)
        function applyPoisonEffect(target) {
            // Don't poison already poisoned units
            if (target.isPoisoned) return;
            
            // Store the original attack speed
            if (!target.originalAttackSpeed) {
                target.originalAttackSpeed = target.attackSpeed;
            }
            
            // Store the original move speed
            if (!target.originalMoveSpeed) {
                target.originalMoveSpeed = target.moveSpeed;
            }
            
            // Apply poison effect
            target.isPoisoned = true;
            target.poisonDuration = 5; // 5 seconds duration
            
            // Slow attack speed by 50%
            target.attackSpeed = target.originalAttackSpeed * 0.5;
            
            // Slow movement speed by 50%
            target.moveSpeed = target.originalMoveSpeed * 0.5;
            
            // Add visual indicator for poisoned units
            target.poisonColor = '#22AA22'; // Green tint for poison effect
            
            console.log(`Applied poison to ${target.type}, slowing attack speed from ${target.originalAttackSpeed} to ${target.attackSpeed} and movement speed from ${target.originalMoveSpeed} to ${target.moveSpeed} for 5 seconds`);
        }
        
        // Update the updateUnits function to handle poison duration
        function updateUnits(deltaTime) {
            for (let i = gameState.activeUnits.length - 1; i >= 0; i--) {
                const unit = gameState.activeUnits[i];
                
                // Update poison duration
                if (unit.isPoisoned) {
                    unit.poisonDuration -= deltaTime;
                    // Remove poison effect when duration ends
                    if (unit.poisonDuration <= 0) {
                        unit.isPoisoned = false;
                        unit.attackSpeed = unit.originalAttackSpeed;
                        unit.moveSpeed = unit.originalMoveSpeed;
                        delete unit.poisonColor;
                        console.log(`Poison effect ended on ${unit.type}, attack speed restored to ${unit.attackSpeed} and movement speed restored to ${unit.moveSpeed}`);
                    }
                }
                
                // Handle attack cooldown
                if (unit.attackCooldown > 0) {
                    unit.attackCooldown -= deltaTime;
                }
                
                // Handle heal cooldown for priestess
                if (unit.type === 'priestess' && unit.healCooldown > 0) {
                    unit.healCooldown -= deltaTime;
                }
                
                // Handle Arc Lightning cooldown for mage
                if (unit.type === 'mage' && unit.hasArcLightning) {
                    if (unit.arcLightningCooldown > 0) {
                        unit.arcLightningCooldown -= deltaTime;
                    }
                }
                
                // Decrease attack animation
                if (unit.attackAnimation > 0) {
                    unit.attackAnimation -= deltaTime;
                }
                
                // Find a target if none exists or current target is dead
                if (!unit.target || unit.target.health <= 0) {
                    unit.target = findTarget(unit);
                }
                
                // Handle priestess healing
                if (unit.type === 'priestess') {
                    // Find injured friendly units in range
                    const injuredAllies = gameState.activeUnits.filter(u => 
                        u.isPlayer === unit.isPlayer && 
                        u !== unit && 
                        u.health < unitTypes[u.type].health &&
                        distance(unit, u) <= unit.healRange
                    );
                    
                    // Calculate the "need to heal" factor - how badly allies need healing
                    let healingPriority = 0;
                    if (injuredAllies.length > 0) {
                        // Find the most injured ally
                        const mostInjured = injuredAllies.reduce((prev, current) => 
                            (prev.health / unitTypes[prev.type].health) < (current.health / unitTypes[current.type].health) ? prev : current
                        );
                        
                        // Calculate healing priority based on how injured the ally is
                        // 0 = full health, 1 = nearly dead
                        healingPriority = 1 - (mostInjured.health / unitTypes[mostInjured.type].health);
                    }
                    
                    // Count other priestesses nearby to avoid too many healing the same target
                    const nearbyPriestesses = gameState.activeUnits.filter(u => 
                        u.isPlayer === unit.isPlayer && 
                        u !== unit && 
                        u.type === 'priestess' &&
                        distance(unit, u) <= unit.healRange * 1.5
                    ).length;
                    
                    // Shadow priestesses are more aggressive
                    const isAggressive = unit.isShadowPriest || nearbyPriestesses > 1 || healingPriority < 0.3;
                    
                    // If there are injured allies with significant wounds AND not too many other priestesses nearby,
                    // focus on healing. Otherwise, behave more like an attacker
                    if (injuredAllies.length > 0 && healingPriority > 0.3 && nearbyPriestesses < 2) {
                        // Find the most injured ally
                        const mostInjured = injuredAllies.reduce((prev, current) => 
                            (prev.health / unitTypes[prev.type].health) < (current.health / unitTypes[current.type].health) ? prev : current
                        );
                        
                        // Move towards the injured ally if out of heal range
                        const distToAlly = distance(unit, mostInjured);
                        if (distToAlly > unit.healRange) {
                            moveTowards(unit, mostInjured.x, mostInjured.y, deltaTime);
                        } else if (unit.healCooldown <= 0) {
                            // Heal the most injured ally
                            const healAmount = Math.min(unit.healAmount, unitTypes[mostInjured.type].health - mostInjured.health);
                            mostInjured.health += healAmount;
                            
                            // Create healing particle with appropriate color for shadow priests
                            if (unit.isShadowPriest) {
                                particles.push(new HealingParticle(mostInjured.x, mostInjured.y, healAmount, true));
                            } else {
                                particles.push(new HealingParticle(mostInjured.x, mostInjured.y, healAmount, false));
                            }
                            
                            // Set heal cooldown
                            unit.healCooldown = 1 / unit.healSpeed;
                        }
                    } else {
                        // No critically injured allies or too many priestesses nearby
                        // Act like a regular attacker but with shorter attack range

                        // If we're a shadow priest, we're even more aggressive
                        if (unit.isShadowPriest) {
                            // Make shadow priests more willing to attack the base too
                            unit.baseDamage = 15; // Increased from 10 for Shadow Priestesses
                        }
                        
                        // Continue with regular attack behavior
                        if (unit.target) {
                            const distToTarget = distance(unit, unit.target);
                            
                            if (distToTarget <= unit.attackRange) {
                                if (unit.attackCooldown <= 0) {
                                    const damage = calculateDamage(unit, unit.target);
                                    
                                    if (unit.ranged) {
                                        projectiles.push(createProjectile(unit, unit.target, damage));
                                    } else {
                                        unit.target.health -= damage;
                                        particles.push(new DamageParticle(
                                            unit.target.x,
                                            unit.target.y,
                                            damage,
                                            unit.isPlayer,
                                            false,
                                            unit.damageType
                                        ));
                                    }
                                    
                                    unit.attackCooldown = 1 / unit.attackSpeed;
                                    unit.attackAnimation = 0.3;
                                    
                                    if (unit.target.health <= 0) {
                                        const targetIndex = gameState.activeUnits.indexOf(unit.target);
                                        if (targetIndex > -1) {
                                            gameState.activeUnits.splice(targetIndex, 1);
                                        }
                                        unit.target = null;
                                    }
                                }
                            } else {
                                // Move towards target
                                moveTowards(unit, unit.target.x, unit.target.y, deltaTime);
                            }
                        } else {
                            // If no target, find one or move towards enemy base
                            unit.target = findTarget(unit);
                            if (!unit.target) {
                                // Move towards enemy base
                                const targetBase = unit.isPlayer ? gameAreas.enemyBase : gameAreas.playerBase;
                                let targetBaseX = targetBase && isFinite(targetBase.x) ? targetBase.x + targetBase.width/2 : canvas.width/2;
                                let targetBaseY = targetBase && isFinite(targetBase.y) ? targetBase.y + targetBase.height/2 : canvas.height/2;
                                targetBaseX = Math.max(0, Math.min(canvas.width, targetBaseX));
                                targetBaseY = Math.max(0, Math.min(canvas.height, targetBaseY));
                                
                                moveTowards(unit, targetBaseX, targetBaseY, deltaTime);
                            }
                        }
                    }
                    
                    // Skip the regular attack logic for priestesses, unless it's a Shadow Priestess
                    // (REMOVE the next line so all priestesses can attack base)
                }
                
                // Attack target if in range
                if (unit.target) {
                    const distToTarget = distance(unit, unit.target);
                    
                    if (distToTarget <= unit.attackRange) {
                        if (unit.attackCooldown <= 0) {
                            const damage = calculateDamage(unit, unit.target);
                            
                            if (unit.ranged) {
                                projectiles.push(createProjectile(unit, unit.target, damage));
                                
                                // Check for Arc Lightning special attack
                                if (unit.type === 'mage' && unit.hasArcLightning && unit.arcLightningCooldown <= 0) {
                                    // Trigger Arc Lightning
                                    triggerArcLightning(unit, unit.target);
                                    // Reset the cooldown
                                    unit.arcLightningCooldown = unit.arcLightningInterval;
                                }
                                
                                // Check for Poison Arrow effect
                                if (unit.type === 'archer' && unit.hasPoisonArrow) {
                                    // Add poison effect to the projectile
                                    const lastIndex = projectiles.length - 1;
                                    projectiles[lastIndex].hasPoisonEffect = true;
                                }
                            } else {
                                unit.target.health -= damage;
                                
                                // Apply poison effect if needed (melee units)
                                if (unit.hasPoisonEffect) {
                                    applyPoisonEffect(unit.target);
                                }
                                
                                // Add damage particle for melee hits with damage type
                                particles.push(new DamageParticle(
                                    unit.target.x,
                                    unit.target.y,
                                    damage,
                                    unit.isPlayer,
                                    false,
                                    unit.damageType
                                ));
                            }
                            
                            unit.attackCooldown = 1 / unit.attackSpeed;
                            unit.attackAnimation = 0.3;
                            
                            if (unit.target.health <= 0) {
                                const targetIndex = gameState.activeUnits.indexOf(unit.target);
                                if (targetIndex > -1) {
                                    gameState.activeUnits.splice(targetIndex, 1);
                                }
                                unit.target = null;
                            }
                        }
                    } else {
                        // Move towards target
                        moveTowards(unit, unit.target.x, unit.target.y, deltaTime);
                    }
                } else {
                    // Move towards enemy base
                    const targetBase = unit.isPlayer ? gameAreas.enemyBase : gameAreas.playerBase;
                    let targetBaseX = targetBase && isFinite(targetBase.x) ? targetBase.x + targetBase.width/2 : canvas.width/2;
                    let targetBaseY = targetBase && isFinite(targetBase.y) ? targetBase.y + targetBase.height/2 : canvas.height/2;
                    // Clamp base target to canvas
                    targetBaseX = Math.max(0, Math.min(canvas.width, targetBaseX));
                    targetBaseY = Math.max(0, Math.min(canvas.height, targetBaseY));
                    
                    // Calculate distance to base
                    const distToBase = distance(unit, { 
                        x: targetBaseX,
                        y: targetBaseY
                    });
                    
                    if (distToBase < BASE_ATTACK_RANGE) {
                        // Unit can attack the base
                        if (unit.attackCooldown <= 0) {
                            const damage = unit.baseDamage;
                            if (unit.isPlayer) {
                                gameState.enemyBaseHealth -= damage;
                                
                                // Add random offset to damage particle position to avoid overlap
                                const offsetX = (Math.random() - 0.5) * 40;
                                const offsetY = (Math.random() - 0.5) * 30;
                                particles.push(new DamageParticle(
                                    targetBaseX + offsetX, 
                                    targetBaseY + offsetY, 
                                    damage, 
                                    true, 
                                    true
                                ));
                                
                                // Apply pillage effect for warriors
                                if (unit.type === 'warrior' && unit.hasPillage) {
                                    const goldStolen = 2; // Reduced from 5 to 2
                                    // Only steal gold if enemy has enough
                                    if (gameState.enemyGold >= goldStolen) {
                                        gameState.enemyGold -= goldStolen;
                                        gameState.playerGold += goldStolen;
                                        
                                        // Show gold stolen particle with offset to avoid overlapping with damage number
                                        particles.push(new GoldParticle(
                                            targetBaseX + 30 + offsetX, 
                                            targetBaseY - 20 + offsetY, 
                                            goldStolen,
                                            true
                                        ));
                                    }
                                }
                            } else {
                                gameState.playerBaseHealth -= damage;
                                
                                // Add random offset to damage particle position to avoid overlap
                                const offsetX = (Math.random() - 0.5) * 40;
                                const offsetY = (Math.random() - 0.5) * 30;
                                particles.push(new DamageParticle(
                                    targetBaseX + offsetX, 
                                    targetBaseY + offsetY, 
                                    damage, 
                                    false, 
                                    true
                                ));
                                
                                // Apply pillage effect for enemy warriors if they have the upgrade (future-proofing)
                                if (unit.type === 'warrior' && unit.hasPillage) {
                                    const goldStolen = 2; // Reduced from 5 to 2
                                    // Only steal gold if enemy has enough
                                    if (gameState.enemyGold >= goldStolen) {
                                        gameState.enemyGold -= goldStolen;
                                        gameState.playerGold += goldStolen;
                                        
                                        // Show gold stolen particle with offset to avoid overlapping with damage number
                                        particles.push(new GoldParticle(
                                            targetBaseX + 30 + offsetX, 
                                            targetBaseY - 20 + offsetY, 
                                            goldStolen,
                                            false
                                        ));
                                    }
                                }
                            }
                            unit.attackCooldown = 1 / unit.attackSpeed;
                            unit.attackAnimation = 0.3;
                        }
                        
                        // Base can attack back with projectile
                        if (unit.isPlayer) {
                            if (gameState.enemyBaseAttackCooldown <= 0) {
                                baseProjectiles.push(createProjectile(
                                    { x: targetBaseX, y: targetBaseY, isPlayer: false },
                                    unit,
                                    BASE_ATTACK_DAMAGE,
                                    true
                                ));
                                gameState.enemyBaseAttackCooldown = BASE_ATTACK_COOLDOWN;
                            }
                        } else {
                            if (gameState.playerBaseAttackCooldown <= 0) {
                                baseProjectiles.push(createProjectile(
                                    { x: targetBaseX, y: targetBaseY, isPlayer: true },
                                    unit,
                                    BASE_ATTACK_DAMAGE,
                                    true
                                ));
                                gameState.playerBaseAttackCooldown = BASE_ATTACK_COOLDOWN;
                            }
                        }
                    } else {
                        // Move towards base if not in range
                        if (isFinite(targetBaseX) && isFinite(targetBaseY)) {
                            moveTowards(unit, targetBaseX, targetBaseY, deltaTime);
                        }
                    }
                }
            }
            
            // Update particles
            particles = particles.filter(p => p.update(deltaTime));
        }

        // Initialize the game
        window.addEventListener('DOMContentLoaded', () => {
          initGame();
        });
    </script>
    <div class="victory-popup">
        <h2>Victory!</h2>
        <div class="gold-awarded">
            <span id="goldPrefix">+</span>
            <span id="victoryGold">0</span>
            <span id="goldSuffix"> gold</span>
        </div>
        <div class="streak">
            <span id="streakLabel">Win Streak</span>: <span id="victoryStreak">0</span>
        </div>
    </div>
</body>
</html>